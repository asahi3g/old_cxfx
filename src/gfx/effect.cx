package gfx

// Globals ...
var g_effects[] Effect // TODO : use map
var g_techniques []Technique // TODO : use map

// Technique ...
type Technique struct {
	key i64
	program Program
}

// EffectId ...
type EffectId struct {
	effect i32
}

// Effect ...
type Effect struct {
	id EffectId

	vertexKey ShaderKey
	pixelKey ShaderKey

	variant i64
	vertexVariant i64
	pixelVariant i64

	program Program
	vertex ShaderId
	pixel ShaderId

	attributes []Attribute
	samplers []Sampler
	uniforms []Uniform
}

// InvalidEffect ...
func InvalidEffect() (out EffectId) {
	out.effect = -1
}

// IsValidEffect ...
func IsValidEffect(id EffectId) (out bool) {
	out = id.effect >= 0 && id.effect < len(g_effects)// && is_valid_program(id.program) ##2 program id ??
}

// EffectCreate ...
func EffectCreate(vertexFilename str, pixelFilename str) (out EffectId) {
	var vertexVariant i64 = ShaderAddVariant(vertexFilename)
	var pixelVariant i64 = ShaderAddVariant(pixelFilename)
	var effectVariant i64 = (vertexVariant << SHADER_VARIANT) | pixelVariant

	var effectCount i32 = len(g_effects)
	for i := 0; i < effectCount; i++ { // TODO : use map
		if g_effects[i].variant == effectVariant {
			out.effect = i
			printf("EFFECT_FOUND %d\n", i)
			return
		}
	}

	out.effect = len(g_effects)

	var effect Effect
	effect.id = out
	effect.variant = effectVariant
	effect.vertexVariant = vertexVariant
	effect.pixelVariant = pixelVariant
	g_effects = append(g_effects, effect)

	panicIfNot(IsValidEffect(out), "invalid id")
}

// EffectVertexKeyClear ...
func EffectVertexKeyClear(id EffectId) {
	panicIfNot(IsValidEffect(id), "invalid id")
	g_effects[id.effect].vertexKey = ShaderKeyClear()
}

// EffectVertexKeySet ...
func EffectVertexKeySet(id EffectId, flag i64, value bool) {
	panicIfNot(IsValidEffect(id), "invalid id")
	g_effects[id.effect].vertexKey = ShaderKeySet(g_effects[id.effect].vertexKey, flag, value)
}

// EffectPixelKeyClear ...
func EffectPixelKeyClear(id EffectId) {
	panicIfNot(IsValidEffect(id), "invalid id")
	g_effects[id.effect].pixelKey = ShaderKeyClear()
}

// EffectPixelKeySet ...
func EffectPixelKeySet(id EffectId, flag i64, value bool) {
	panicIfNot(IsValidEffect(id), "invalid id")
	g_effects[id.effect].pixelKey = ShaderKeySet(g_effects[id.effect].pixelKey, flag, value)
}

// EffectIsValidSamplerSlot ...
func EffectIsValidSamplerSlot(id EffectId, slot i32) (out bool) {
	panicIfNot(IsValidEffect(id), "invalid id")
	out = slot >= 0 && slot < len(g_effects[id.effect].samplers)
}

// EffectIsValidUniformSlot ...
func EffectIsValidUniformSlot(id EffectId, slot i32) (out bool) {
	panicIfNot(IsValidEffect(id), "invalid id")
	out = slot >= 0 && slot < len(g_effects[id.effect].uniforms)
}

// EffectIsValidUniformLocation ...
func EffectIsValidUniformLocation(id EffectId, slot i32) (out bool) {
	out = false
	panicIfNot(IsValidEffect(id), "invalid id")
	if EffectIsValidUniformSlot(id, slot) {
		out = g_effects[id.effect].uniforms[slot].location >= 0
	}
}

// EffectBindAttribute ...
func EffectBindAttribute(id EffectId, location i32, name str) {
	panicIfNot(IsValidEffect(id), "invalid id")
	BindAttribute(g_effects[id.effect].program, location, name)
	g_effects[id.effect].attributes = append(g_effects[id.effect].attributes, NewAttribute(location, name))
}

// EffectBindSampler ...
func EffectBindSampler(id EffectId, name str) {
	panicIfNot(IsValidEffect(id), "invalid id")
	var location i32 = BindTexture(g_effects[id.effect].program, name)
	g_effects[id.effect].samplers = append(g_effects[id.effect].samplers, NewSampler(location, name))
}

// EffectBindUniform ...
func EffectBindUniform(id EffectId, name str) {
	panicIfNot(IsValidEffect(id), "invalid id")
	var location i32 = BindUniform(g_effects[id.effect].program, name)
	g_effects[id.effect].uniforms = append(g_effects[id.effect].uniforms, NewUniform(location, name))
}

// EffectTryBindUniform ...
func EffectTryBindUniform(id EffectId, name str) {
	panicIfNot(IsValidEffect(id), "invalid id")
	var location i32 = TryBindUniform(g_effects[id.effect].program, name)
	g_effects[id.effect].uniforms = append(g_effects[id.effect].uniforms, NewUniform(location, name))
}

// EffectUse ...
func EffectUse(id EffectId) () {
	panicIfNot(IsValidEffect(id), "invalid id")
	var effectVariant i64 = g_effects[id.effect].variant

	var vertexVariant i64 = g_effects[id.effect].vertexVariant
	var vertexFlags i64 = g_effects[id.effect].vertexKey.value
	var vertexKey i64 = (vertexFlags << SHADER_VARIANT) | vertexVariant
	var vertexShader ShaderId = ShaderCreate(SHADER_VERTEX, vertexVariant, vertexFlags, vertexKey)

	var pixelVariant i64 = g_effects[id.effect].pixelVariant
	var pixelFlags i64 = g_effects[id.effect].pixelKey.value
	var pixelKey i64 = (pixelFlags << SHADER_VARIANT) | pixelVariant
	var pixelShader ShaderId = ShaderCreate(SHADER_PIXEL, pixelVariant, pixelFlags, pixelKey)

	var techniqueIndex i32 = -1
	var techniqueKey i64 = vertexKey << 32L | pixelKey
	var count i32 = len(g_techniques)
	for i := 0; i < count; i++ { // ISSUE : use map
		if g_techniques[i].key == techniqueKey {
			techniqueIndex = i
			i = count // ISSUE : use break
		}
	}

	if techniqueIndex < 0 {
		var technique Technique
		technique.key = techniqueKey
		technique.program = ProgramCreate(ShaderGetGlsl(vertexShader), ShaderGetGlsl(pixelShader))
		techniqueIndex = len(g_techniques)
		g_techniques = append(g_techniques, technique)
	}

	var program Program = g_techniques[techniqueIndex].program
	g_effects[id.effect].program = program
	UseProgram(program)
}

// EffectAssignTexture ...
func EffectAssignTexture(id EffectId, slot i32, texture TextureId) () {
	panicIfNot(IsValidEffect(id), "invalid effect")
	panicIfNot(EffectIsValidSamplerSlot(id, slot), "invalid sampler slot")
	panicIfNot(IsValidTexture(texture), "invalid texture")
	assignTexture(TextureTarget(texture), slot, g_effects[id.effect].samplers[slot].location, TextureName(texture))
}

// EffectRemoveTexture ...
func EffectRemoveTexture(id EffectId, slot i32, target i32) {
	panicIfNot(IsValidEffect(id), "invalid id")
	panicIfNot(EffectIsValidSamplerSlot(id, slot), "invalid sampler slot")
	assignTexture(target, slot, g_effects[id.effect].samplers[slot].location, 0)
}

// EffectAssignFloat ...
func EffectAssignFloat(id EffectId, slot i32, value f32) {
	panicIfNot(IsValidEffect(id), "invalid id")
	panicIfNot(EffectIsValidUniformSlot(id, slot), "invalid uniform slot")
	assignFloat(g_effects[id.effect].uniforms[slot].location, value)
}

// EffectAssignVector4 ...
func EffectAssignVector4(id EffectId, slot i32, value []f32) {
	panicIfNot(IsValidEffect(id), "invalid id")
	panicIfNot(EffectIsValidUniformSlot(id, slot), "invalid uniform slot")
	assignVector4(g_effects[id.effect].uniforms[slot].location, value)
}

// EffectAssignMatrix4 ...
func EffectAssignMatrix4(id EffectId, slot i32, value []f32, transpose bool) {
	panicIfNot(IsValidEffect(id), "invalid id")
	panicIfNot(EffectIsValidUniformSlot(id, slot), "invalid uniform slot")
	assignMatrix4(g_effects[id.effect].uniforms[slot].location, value, transpose)
}

