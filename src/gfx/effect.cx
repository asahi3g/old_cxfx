package gfx

// Globals ...
var g_effects[] Effect

// EffectId ...
type EffectId struct {
	effect i32
}

// Effect ...
type Effect struct {
	id EffectId
	program Program
	vertex str
	pixel str
	attributes []Attribute
	samplers []Sampler
	uniforms []Uniform
}

// InvalidEffect ...
func InvalidEffect() (out EffectId) {
	out.effect = -1
}

// IsValidEffect ...
func IsValidEffect(id EffectId) (out bool) {
	out = id.effect >= 0 && id.effect < len(g_effects)// && is_valid_program(id.program) ##2 program id ??
}

// EffectCreate ...
func EffectCreate() (out EffectId) {
	out.effect = len(g_effects)

	var effect Effect
	effect.id = out
	effect.program = NullProgram()

	g_effects = append(g_effects, effect)

	panicIfNot(IsValidEffect(out), "invalid id")
}

// EffectCompile ...
func EffectCompile(id EffectId) {
	panicIfNot(IsValidEffect(id), "invalid id")
	var vertex str = g_effects[id.effect].vertex
	//printf("// vertex --------------------------------------------> :\n%s\n", vertex)
	var pixel str = g_effects[id.effect].pixel
	//printf("// pixel  --------------------------------------------> :\n%s\n", pixel)
	g_effects[id.effect].program = ProgramCreate(vertex, pixel)
}

// EffectAppendVertexSource ...
func EffectAppendVertexSource(id EffectId, source str) {
	panicIfNot(IsValidEffect(id), "invalid id")
	var vertex str = g_effects[id.effect].vertex
	vertex = str.concat(vertex, source) // ISSUE : can't concat with operator +
	g_effects[id.effect].vertex = vertex
}

// EffectAppendPixelSource ...
func EffectAppendPixelSource(id EffectId, source str) {
	panicIfNot(IsValidEffect(id), "invalid id")
	var pixel str = g_effects[id.effect].pixel
	pixel = str.concat(pixel, source)
	g_effects[id.effect].pixel = pixel
}

// EffectIsValidSamplerSlot ...
func EffectIsValidSamplerSlot(id EffectId, slot i32) (out bool) {
	panicIfNot(IsValidEffect(id), "invalid id")
	out = slot >= 0 && slot < len(g_effects[id.effect].samplers)
}

// EffectIsValidUniformSlot ...
func EffectIsValidUniformSlot(id EffectId, slot i32) (out bool) {
	panicIfNot(IsValidEffect(id), "invalid id")
	out = slot >= 0 && slot < len(g_effects[id.effect].uniforms)
}

// EffectIsValidUniformLocation ...
func EffectIsValidUniformLocation(id EffectId, slot i32) (out bool) {
	out = false
	panicIfNot(IsValidEffect(id), "invalid id")
	if EffectIsValidUniformSlot(id, slot) {
		out = g_effects[id.effect].uniforms[slot].location >= 0
	}
}


// EffectUse ...
func EffectUse(id EffectId) () {
	panicIfNot(IsValidEffect(id), "invalid id")
	UseProgram(g_effects[id.effect].program)
}

// EffectBindAttribute ...
func EffectBindAttribute(id EffectId, location i32, name str) {
	panicIfNot(IsValidEffect(id), "invalid id")
	BindAttribute(g_effects[id.effect].program, location, name)
	g_effects[id.effect].attributes = append(g_effects[id.effect].attributes, NewAttribute(location, name))
}

// EffectBindSampler ...
func EffectBindSampler(id EffectId, name str) {
	panicIfNot(IsValidEffect(id), "invalid id")
	var location i32 = BindTexture(g_effects[id.effect].program, name)
	g_effects[id.effect].samplers = append(g_effects[id.effect].samplers, NewSampler(location, name))
}

// EffectBindUniform ...
func EffectBindUniform(id EffectId, name str) {
	panicIfNot(IsValidEffect(id), "invalid id")
	var location i32 = BindUniform(g_effects[id.effect].program, name)
	g_effects[id.effect].uniforms = append(g_effects[id.effect].uniforms, NewUniform(location, name))
}

// EffectTryBindUniform ...
func EffectTryBindUniform(id EffectId, name str) {
	panicIfNot(IsValidEffect(id), "invalid id")
	var location i32 = TryBindUniform(g_effects[id.effect].program, name)
	g_effects[id.effect].uniforms = append(g_effects[id.effect].uniforms, NewUniform(location, name))
}

// EffectAssignTexture ...
func EffectAssignTexture(id EffectId, slot i32, texture TextureId) () {
	panicIfNot(IsValidEffect(id), "invalid effect")
	panicIfNot(EffectIsValidSamplerSlot(id, slot), "invalid sampler slot")
	panicIfNot(IsValidTexture(texture), "invalid texture")
	assignTexture(TextureTarget(texture), slot, g_effects[id.effect].samplers[slot].location, TextureName(texture))
}

// EffectRemoveTexture ...
func EffectRemoveTexture(id EffectId, slot i32, target i32) {
	panicIfNot(IsValidEffect(id), "invalid id")
	panicIfNot(EffectIsValidSamplerSlot(id, slot), "invalid sampler slot")
	assignTexture(target, slot, g_effects[id.effect].samplers[slot].location, 0)
}

// EffectAssignFloat ...
func EffectAssignFloat(id EffectId, slot i32, value f32) {
	panicIfNot(IsValidEffect(id), "invalid id")
	panicIfNot(EffectIsValidUniformSlot(id, slot), "invalid uniform slot")
	assignFloat(g_effects[id.effect].uniforms[slot].location, value)
}

// EffectAssignVector4 ...
func EffectAssignVector4(id EffectId, slot i32, value []f32) {
	panicIfNot(IsValidEffect(id), "invalid id")
	panicIfNot(EffectIsValidUniformSlot(id, slot), "invalid uniform slot")
	assignVector4(g_effects[id.effect].uniforms[slot].location, value)
}

// EffectAssignMatrix4 ...
func EffectAssignMatrix4(id EffectId, slot i32, value []f32, transpose bool) {
	panicIfNot(IsValidEffect(id), "invalid id")
	panicIfNot(EffectIsValidUniformSlot(id, slot), "invalid uniform slot")
	assignMatrix4(g_effects[id.effect].uniforms[slot].location, value, transpose)
}
