package gfx

import "gltf"

// Constants ...
var MODEL_GEOMETRY i32 = 1
var MODEL_ANIMATION i32 = 2

// Globals ...
var g_models []Model
var g_animations []Animation // ISSUE : can't be named g_animations as it clashes at runtime with src/gui/animation.cx::g_animations

// AnimationId ...
type AnimationId struct {
	animation i32
}

// AnimationSource ...
type AnimationSource struct {
	offset i32
	count i32
}

// Animation ...
type Animation struct {
	asset gltf.AssetId
	channels []gltf.AnimationChannel
	samplers []gltf.AnimationSampler
	sources []AnimationSource
	indices []i32
	time f32
	direction f32
	min f32
	max f32
	transforms []f32
	trs []f32
	animated []bool
}

// AnimationIsValid ...
func AnimationIsValid(id AnimationId) (out bool) {
	out = id.animation >= 0 && id.animation < len(g_animations)
}

// AnimationInvalid ...
func AnimationInvalid()(out AnimationId) {
	out.animation = -1
}

// AnimationCreate ...
func AnimationCreate()(out AnimationId) {
	out.animation = len(g_animations)

	var animation Animation
	animation.direction = 1.0
	g_animations = append(g_animations, animation)
}

type Skeleton struct {
	root i32
}

type Primitive struct {
	mesh MeshId
	node i32
	nodeIndex i32

	effect EffectId

	useSkin i32
	baseTexture TextureId
	metalRoughTexture TextureId
	emissiveTexture TextureId
	normalTexture TextureId
	occlusionTexture TextureId

	gltfPrimitive gltf.Primitive
	gltfMaterial gltf.Material
}

// ModelId ...
type ModelId struct {
	model i32
}

// Model ...
type Model struct {
	asset gltf.AssetId

	dataDir str
	filename str

   	animated bool
	skinned bool

	min mat.v3
	max mat.v3

	nodes[]i32
	nodesMap[]i32
	determinants []f32
	transforms []f32
	matrixStack []f32

	meshes []i32
	meshCacheKey []i32
	meshCacheVal []MeshId
	primitives []Primitive
	opaqueMeshes []i32
	transparentMeshes []i32

	skeleton Skeleton

	animations []AnimationId

	environmentSpecular TextureId // TODO : remove
	environmentDiffuse TextureId // TODO : remove
	brdf TextureId // TODO : remove
	cameraPosition []f32 // TODO : remove

	inverseBind []f32 // TODO : skeleton struct
	joints []i32 // TODO : skeleton struct
	jointMatrices []f32 // TODO : runtime struct

	stack []i32 // TODO : remove
	color []f32 // TODO : remove
	identity []f32 // TODO : remove
	world []f32 // TODO : remove
	view []f32 // TODO : remove
	projection []f32 // TODO : remove
	tmp []f32 // TODO : remove
	tmp2 []f32 // TODO : remove
}

// ModelIsValid ...
func ModelIsValid(id ModelId) (out bool) {
	out = id.model >= 0 && id.model < len(g_models)
}

// ModelInvalid ...
func ModelInvalid() (out ModelId) {
	out.model = -1
}

// ModelCreate ...
func ModelCreate() (out ModelId) {
	out.model = len(g_models)

	var model Model
	model.color = resize(model.color, 4)
	model.color[0] = 1.0
	model.color[1] = 0.0
	model.color[2] = 1.0
	model.color[3] = 1.0

	var tmp []f32 = mat.MatrixAlloc()
	model.tmp = tmp

	var tmp2 []f32 = mat.MatrixAlloc()
	model.tmp2 = tmp2

	var world []f32 = mat.MatrixAlloc()
	model.world = world

	var view []f32 = mat.MatrixAlloc()
	model.view = view

	var projection []f32 = mat.MatrixAlloc()
	model.projection = projection

	var identity []f32 = mat.MatrixAlloc()
	model.identity = mat.MatrixIdentity(identity)

	model.skeleton.root = -1
	model.asset = gltf.AssetInvalid()
	g_models = append(g_models, model)
}

// ModelCreateFromFile ...
func ModelCreateFromFile(dataDir str, filename str, options i32) (out ModelId){ // TODO : only load animations
	out = ModelCreate()

	var modelIndex i32 = out.model
	g_models[modelIndex].dataDir = dataDir
	g_models[modelIndex].filename = filename

	var asset gltf.AssetId = gltf.AssetCreate(dataDir, filename, options)
	if gltf.AssetIsValid(asset) == false {
		printf("gltf.AssetCreate failed\n")
		out = ModelInvalid()
		return
	}

	g_models[modelIndex].asset = asset
	//gltf.AssetPrint(asset)

	if modelInstance(out) == false {
		printf("modelInstance failed\n")
		out = ModelInvalid()
		return
	}

	modelTransform(out, AnimationInvalid(), 0.0, false)
}

// ModelGetMin ...
func ModelGetMin(id ModelId) (out mat.v3) {
	panicIfNot(ModelIsValid(id), "invalid model")
	out = g_models[id.model].min
}

// ModelGetMax ...
func ModelGetMax(id ModelId) (out mat.v3) {
	panicIfNot(ModelIsValid(id), "invalid model")
	out = g_models[id.model].max
}

// ModelGetAnimation ...
func ModelGetAnimation(id ModelId, animationIndex i32) (out AnimationId) {
	out = AnimationInvalid()
	panicIfNot(ModelIsValid(id), "invalid model")

	var modelIndex i32 = id.model
	var animationCount i32 = len(g_models[modelIndex].animations)
	if animationIndex >= 0 && animationIndex < animationCount {
		out = g_models[modelIndex].animations[animationIndex]
	}
}

// ModelGetNodeByName ...
func ModelGetNodeByName(id ModelId, name str) (out i32) {
	out = -1
	panicIfNot(ModelIsValid(id), "invalid model")

	var modelIndex i32 = id.model
	var asset gltf.AssetId = g_models[modelIndex].asset
	var nodeCount i32 = gltf.AssetGetNodeCount(asset)
	for i := 0; i < nodeCount; i++ {
		var nodeName str = gltf.NodeGetName(asset, i)
		if nodeName == name {
			out = i
			return
		}
	}
}

type channelInfo struct {
	count i32
	dataType i32
	dataLen i32
	dataF32 []f32
	dataUI8 []ui8
	dataUI16 []ui16
	dataUI32 []ui32
}

func effectInstance(primitive *Primitive) (out EffectId) {
	var mesh MeshId = primitive.mesh

	var useColorVtx bool = MeshUseColor(mesh)
	var useColorMap bool = IsValidTexture(primitive.baseTexture)
	var useColorUni bool = useColorMap

	var usePbrMap bool = IsValidTexture(primitive.metalRoughTexture)
	var usePbrUni bool = usePbrMap == false

	var useEmissiveMap bool = IsValidTexture(primitive.emissiveTexture)
	var useEmissiveUni bool = useEmissiveMap == false

	var useNormalMap bool = IsValidTexture(primitive.normalTexture)
	var useNormalVtx bool = MeshUseNormal(mesh)
	var useTangentVtx bool = MeshUseTangent(mesh)

	var useOcclusionTexture bool = IsValidTexture(primitive.occlusionTexture)

	var useWeights bool = MeshUseWeight(mesh)
	var useJoints bool = MeshUseJoint(mesh)
	var useSkin bool = useWeights && useJoints

	/*printf("EFFECT_INSTANCE\n")
	if useColorVtx {
		printf("USE_COLOR_VTX\n")
	}
	if useColorMap {
		printf("USE_COLOR_MAP\n")
	}
	if useColorUni {
		printf("USE_COLOR_UNI\n")
	}
	if usePbrMap {
		printf("USE_PBR_MAP\n")
	}
	if usePbrUni {
		printf("USE_PBR_UNI\n")
	}
	if useEmissiveMap {
		printf("USE_EMIS_MAP\n")
	}
	if useEmissiveUni {
		printf("USE_EMIS_UNI\n")
	}
	if useNormalMap {
		printf("USE_NORMAL_MAP\n")
	}
	if useNormalVtx {
		printf("USE_NORMAL_VTX\n")
	}
	if useTangentVtx {
		printf("USE_TANGENT_VTX\n")
	}
	if useOcclusionTexture {
		printf("USE_OCCLUSION_TEXTURE\n")
	}
	if useWeights {
		printf("USE_WEIGHTS\n")
	}
	if useJoints {
		printf("USE_JOINTS\n")
	}
	if useSkin {
		printf("USE_SKIN\n")
	}*/
	TemplateSetKey(g_tfxPbr, USE_COLOR_UNI, useColorUni)
	TemplateSetKey(g_tfxPbr, USE_COLOR_VTX, useColorVtx)
	TemplateSetKey(g_tfxPbr, USE_COLOR_MAP, useColorMap)

	TemplateSetKey(g_tfxPbr, USE_PBR_UNI, usePbrUni)
	TemplateSetKey(g_tfxPbr, USE_PBR_MAP, usePbrMap)

	TemplateSetKey(g_tfxPbr, USE_EMISSIVE_UNI, useEmissiveUni)
	TemplateSetKey(g_tfxPbr, USE_EMISSIVE_MAP, useEmissiveMap)

	TemplateSetKey(g_tfxPbr, USE_NORMAL_VTX, useNormalVtx)
	TemplateSetKey(g_tfxPbr, USE_NORMAL_MAP, useNormalMap)
	TemplateSetKey(g_tfxPbr, USE_TANGENT_VTX, useTangentVtx)

	TemplateSetKey(g_tfxPbr, USE_OCCLUSION_MAP, useOcclusionTexture)

	TemplateSetKey(g_tfxPbr, USE_SKIN, useSkin)

	TemplateSetKey(g_tfxPbr, USE_DEBUG_A, true)

	out = TemplateInstance(g_tfxPbr)
}

func meshInstance(id gltf.AssetId, primitive gltf.Primitive) (out MeshId) {
	var mode i32
	//printf("instancing : mode %d, indices %d, material %d\n", primitive.mode, primitive.indices, primitive.material)
	if primitive.mode == gltf.PRIMITIVE_LINES {
		mode = gl.LINES
	} else if primitive.mode == gltf.PRIMITIVE_TRIANGLES {
		mode = gl.TRIANGLES
	} else {
		printf("primitive type not implemented\n")
		out = InvalidMesh()
		return
	}

	var min mat.v3
	var max mat.v3

	var usePosition bool
	var useNormal bool
	var useColor bool
	var useTexcoord bool
	var useTangent bool
	var useWeight bool
	var useJoint bool

	// attributes
	var channels []channelInfo
	var attributes []VertexAttribute
	var vertexCount i32 = 0
	var attributeCount i32 = len(primitive.attributes)
	var byteStride i32 = 0
	var componentStride i32 = 0
	for a := 0; a < attributeCount; a++ {
		var accessor gltf.Accessor = gltf.AssetGetAccessor(id, primitive.attributes[a].accessor)
		if a > 0 && accessor.count != vertexCount {
			printf("wrong number of vectices\n")
			out = InvalidMesh()
			return
		}

		vertexCount = accessor.count

   		var channel channelInfo
		var attribute VertexAttribute

		if accessor.componentType == gl.FLOAT { // TODO : how to pass []struct to BufferData ?
			channel.dataF32 = accessor.dataF32
			channel.dataLen = len(channel.dataF32)
   			channel.dataType = gl.FLOAT
			attribute.componentType = gl.FLOAT
			attribute.componentByteSize = g_sizeofF32
		} else if accessor.componentType == gl.UNSIGNED_SHORT {
			channel.dataUI16 = accessor.dataUI16
			channel.dataLen = len(channel.dataUI16)
   			channel.dataType = gl.UNSIGNED_SHORT
			attribute.componentType = gl.UNSIGNED_SHORT
			attribute.componentByteSize = g_sizeofUI16
		} else if accessor.componentType == gl.UNSIGNED_INT {
			channel.dataUI32 = accessor.dataUI32
			channel.dataLen = len(channel.dataUI32)
			channel.dataType = gl.UNSIGNED_INT
			attribute.componentType = gl.UNSIGNED_INT
			attribute.componentByteSize = g_sizeofUI32
		} else {
			printf("buffer type not implemented %d\n", accessor.componentType)
			out = InvalidMesh()
			return
		}

		attribute.componentCount = accessor.componentCount
		attribute.componentOffset = componentStride
		attribute.byteOffset = byteStride

		var attributeType i32 = primitive.attributes[a].attributeType
		var binding i32 = -1
		if attributeType == gltf.ATTRIBUTE_POSITION {
			binding = ATTRIBUTE_POSITION
			min.x = accessor.min[0]
			min.y = accessor.min[1]
			min.z = accessor.min[2]
			max.x = accessor.max[0]
			max.y = accessor.max[1]
			max.z = accessor.max[2]
		} else if attributeType == gltf.ATTRIBUTE_NORMAL {
			binding = ATTRIBUTE_NORMAL
			useNormal = true
		} else if attributeType == gltf.ATTRIBUTE_COLOR {
			binding = ATTRIBUTE_COLOR
			useColor = true
		} else if attributeType == gltf.ATTRIBUTE_TEXCOORD {
			binding = ATTRIBUTE_TEXCOORD
			useTexcoord = true
		} else if attributeType == gltf.ATTRIBUTE_TANGENT {
			binding = ATTRIBUTE_TANGENT
			useTangent = true
		} else if attributeType == gltf.ATTRIBUTE_WEIGHT {
			binding = ATTRIBUTE_WEIGHT
			useWeight = true
		} else if attributeType == gltf.ATTRIBUTE_JOINT {
			binding = ATTRIBUTE_JOINT
			useJoint = true
		}

		attribute.binding = binding
		channel.count = attribute.componentCount

		attributes = append(attributes, attribute)
		channels = append(channels, channel)

		byteStride = byteStride + attribute.componentCount * attribute.componentByteSize
		componentStride = componentStride + attribute.componentCount
	}

	var vertexLen i32 = componentStride * vertexCount
	if vertexLen <= 0 {
		printf("invalid vertex buffer\n")
		out = InvalidMesh()
		return
	}

	// vertices // TODO : generate buffers from go data ?
	var vertices []ui8 // TODO : test perf with loop reordering + resize(vertices, vertexLen)
	for v := 0; v < vertexCount; v++ {
		for c := 0; c < attributeCount; c++ {
			var dataType i32 = channels[c].dataType
			var dataLen i32 = channels[c].dataLen
			var count i32 = channels[c].count
			var offset i32 = v * count
			if dataType == gl.FLOAT {
				var data []f32 = channels[c].dataF32
				for i := 0; i < count; i++ {
					vertices = gl.AppendF32(vertices, data[offset + i])
				}
			} else if dataType == gl.UNSIGNED_SHORT {
				var data []ui16 = channels[c].dataUI16
				for i := 0; i < count; i++ {
					vertices = gl.AppendUI16(vertices, data[offset + i])
				}
			} else if dataType == gl.UNSIGNED_INT {
				var data []ui32 = channels[c].dataUI32
				for i := 0; i < count; i++ {
					vertices = gl.AppendUI32(vertices, data[offset + i])
				}
			} else {
				panicIf(true, "unhandled dataType")
			}
		}
	}

	// indices
	var indices []ui8
	var indicesAccessor gltf.Accessor = gltf.AssetGetAccessor(id, primitive.indices)
	var indicesType i32 = indicesAccessor.componentType
	if indicesAccessor.componentCount != 1 ||
	   (indicesAccessor.componentType != gl.UNSIGNED_SHORT && indicesAccessor.componentType != gl.UNSIGNED_INT) ||
	   indicesAccessor.attributeTypeEnum != gltf.TYPE_SCALAR {
		printf("invalid index buffer format : componentCount %d, componentType %d, attributeType %d\n",
			indicesAccessor.componentCount, indicesAccessor.componentType, indicesAccessor.attributeTypeEnum)
		out = InvalidMesh()
		return
	}

	var indexByteCount i32 = 0
	if indicesType == gl.UNSIGNED_SHORT {
		var data []ui16 = indicesAccessor.dataUI16
		var count i32 = len(data)
		indexByteCount = 2
		for i := 0; i < count; i++ {
			indices = gl.AppendUI16(indices, data[i])
		}
	} else if indicesType == gl.UNSIGNED_INT {
		var data []ui32 = indicesAccessor.dataUI32
		var count i32 = len(data)
		indexByteCount = 4
		for i := 0; i < count; i++ {
			indices = gl.AppendUI32(indices, data[i])
		}
	} else {
		printf("invalid index buffer type\n")
		out = InvalidMesh()
		return
	}

	if len(attributes) > 0 && len(indices) > 0 && len(vertices) > 0 {
		out = MeshCreate(mode, indicesType, len(indices) / indexByteCount, attributes, len(vertices) / byteStride) // TODO : use real index/vertex count instead of bytecount
		MeshBegin(out) // TODO : remove MeshBegin/MeshEnd, data should be uploaded with BufferData in MeshInstance.
		g_meshes[out.mesh].vertices = vertices
		g_meshes[out.mesh].indices = indices
		g_meshes[out.mesh].usePosition = usePosition
		g_meshes[out.mesh].useNormal = useNormal
		g_meshes[out.mesh].useColor = useColor
		g_meshes[out.mesh].useTexcoord = useTexcoord
		g_meshes[out.mesh].useTangent = useTangent
		g_meshes[out.mesh].useWeight = useWeight
		g_meshes[out.mesh].useJoint = useJoint
		g_meshes[out.mesh].min = min
		g_meshes[out.mesh].max = max
		MeshEnd(out)
	}
}

// ModelSetCameraPosition ...
func ModelSetCameraPosition(id ModelId, position mat.v3) {
	panicIfNot(ModelIsValid(id), "invalid model")
	var cameraPosition []f32 = g_models[id.model].cameraPosition
	cameraPosition = resize(cameraPosition, 4)
	cameraPosition[0] = position.x
	cameraPosition[1] = position.y
	cameraPosition[2] = position.z
	cameraPosition[3] = 1.0
	g_models[id.model].cameraPosition = cameraPosition
}


// ModelSetEnvironmentSpecular ...
func ModelSetEnvironmentSpecular(id ModelId, environment TextureId) { 
	panicIfNot(ModelIsValid(id), "invalid model")
	g_models[id.model].environmentSpecular = environment
}

// ModelSetEnvironmentDiffuse...
func ModelSetEnvironmentDiffuse(id ModelId, environment TextureId) { 
	panicIfNot(ModelIsValid(id), "invalid model")
	g_models[id.model].environmentDiffuse = environment
}

// ModelSetBRDF ...
func ModelSetBRDF(id ModelId, brdf TextureId) {
	panicIfNot(ModelIsValid(id), "invalid model")
	g_models[id.model].brdf = brdf
}

// ModelSetWorld ...
func ModelSetWorld(id ModelId, world []f32) {
	panicIfNot(ModelIsValid(id), "invalid model")
	var i i32 = copy(g_models[id.model].world, world)
}

// ModelSetView ...
func ModelSetView(id ModelId, view []f32) {
	panicIfNot(ModelIsValid(id), "invalid model")
	var i i32 = copy(g_models[id.model].view, view)
}

// ModelSetProjection ...
func ModelSetProjection(id ModelId, projection []f32) {
	panicIfNot(ModelIsValid(id), "invalid model")
	var i i32 = copy(g_models[id.model].projection, projection)
}

func loadTexture(asset AssetId, dataDir str, index i32) (out TextureId) {
	out = InvalidTexture()
	//if gltf.AssetIsValidTexture(asset, index) {
		var texture gltf.Texture = gltf.AssetGetTexture(asset, index)
		var image gltf.Image = gltf.AssetGetImage(asset, texture.source)
		if image.uri != "" {
			out = TextureCreate(sprintf("%s%s", dataDir, image.uri), FORMAT_R8_G8_B8_A8, 0, 0, -1, false)
		}
	//}
}

// ModelUpdate ...
func ModelUpdate(id ModelId, animId AnimationId, deltaTime f32, loop bool) { // TODO : bound check
	panicIfNot(ModelIsValid(id), "invalid model")
	if g_models[id.model].animated || g_models[id.model].skinned {
		modelTransform(id, animId, deltaTime, loop)
	}
}

// ModelRender ...
func ModelRender(id ModelId) {
	DisableBlending()
	DepthState(true, LESS, true)
	modelRender(id, g_models[id.model].opaqueMeshes, 1.0)

	EnableBlending(SRC_ALPHA, ONE_MINUS_SRC_ALPHA)
	DepthState(true, LESS, true)
	modelRender(id, g_models[id.model].transparentMeshes, 1.0)
}

func modelInstance(id ModelId) (success bool) {
	panicIfNot(ModelIsValid(id), "invalid model")
	var modelIndex i32 = id.model

	var stack []i32 = g_models[modelIndex].stack

	var asset gltf.AssetId = g_models[modelIndex].asset
	var roots []i32 = gltf.AssetGetRootNodes(asset)
	var rootCount i32 = len(roots)

	var animations []AnimationId = g_models[modelIndex].animations

	var nodes []i32 = g_models[modelIndex].nodes
	var nodesMap []i32 = g_models[modelIndex].nodesMap

	var determinants []f32 = g_models[modelIndex].determinants
	var meshCacheKey []i32 = g_models[modelIndex].meshCacheKey
	var meshCacheVal []MeshId = g_models[modelIndex].meshCacheVal

	var meshes []i32 = g_models[modelIndex].meshes

	var dataDir str = g_models[modelIndex].dataDir
	var primitives []Primitive = g_models[modelIndex].primitives

	var transparentMeshes []i32 = g_models[modelIndex].transparentMeshes
	var opaqueMeshes []i32 = g_models[modelIndex].opaqueMeshes

	var identity []f32 = g_models[modelIndex].identity

	var matrixStack []f32 = g_models[modelIndex].matrixStack
	matrixStack = resize(matrixStack, 0)
	matrixStack = mat.MatrixStackPush(matrixStack, identity)

	var transforms []f32 = g_models[modelIndex].transforms
	transforms = resize(transforms, 0)

	var min mat.v3 = mat.v3_max_val()
	var max mat.v3 = mat.v3_min_val()

	stack = resize(stack, rootCount)
	for i := 0; i < rootCount; i++ {
		stack[i] = roots[i]
	}

	var gltfAnimations []gltf.Animation = gltf.AssetGetAnimations(asset)
	var animationCount i32 = len(gltfAnimations)
	g_models[modelIndex].animated = animationCount > 0 // TODO : multiple models per scene
	for i := 0; i < animationCount; i++ {

		var channels []gltf.AnimationChannel = gltfAnimations[i].channels

		var animation Animation
		animation.channels = channels
		animation.min, animation.max = gltf.AnimationGetLength(asset, i)

		var offsetCount i32
		var channelCount i32 = len(channels)
		for c := 0; c < channelCount; c++ {
			var channel gltf.AnimationChannel = channels[c]
			var channelNode i32 = channel.node
			if channelNode >= offsetCount {
				offsetCount = channelNode + 1
			}
		}

		var samplers []gltf.AnimationSampler = gltfAnimations[i].samplers
		animation.samplers = samplers

		var sources []AnimationSource
		//sources = resize(sources, offsetCount) // ISSUE : can't use resize
		for o := 0; o < offsetCount; o++ {
			var source AnimationSource
			source.offset = -1
			sources = append(sources, source)
		}
		for c := 0; c < channelCount; c++ {
			var channel gltf.AnimationChannel = channels[c]
			var channelNode i32 = channel.node
			var nodeChannelCount i32 = sources[channelNode].count
			sources[channelNode].count = nodeChannelCount + 1
		}
		var offset i32
		for o := 0; o < offsetCount; o++ {
			sources[o].offset = offset
			offset = offset + sources[o].count
		}

		panicIf(offset != channelCount, "invalid animation")

		var indices []i32
		//indices = resize(indices, channelCount) // ISSUE : can't use resize
		for c := 0; c < channelCount; c++ {
			indices = append(indices, -1)//indices[c] = -1
		}
		for c := 0; c < channelCount; c++ {
			var channel gltf.AnimationChannel = channels[c]
			var channelNode i32 = channel.node
			var nodeChannelOffset i32 = sources[channelNode].offset
			var nodeChannelCount i32 = sources[channelNode].count
			for k := 0; k < nodeChannelCount; k++ {
				var nodeChannelIndex i32 = indices[nodeChannelOffset + k]
				if nodeChannelIndex == -1 {
					indices[nodeChannelOffset + k] = c
					k = nodeChannelCount // TODO : break
				}
			}
		}

		animation.sources = sources
		animation.indices = indices
		animation.direction = 1.0
		animation.asset = asset

		var animId AnimationId = AnimationCreate()
		animations = append(animations, animId)
		g_animations[animId.animation] = animation
	}

	var nodeCount i32 = gltf.AssetGetNodeCount(asset)
	nodesMap = resize(nodesMap, nodeCount)
	for i := 0; i < nodeCount; i++ {
		nodesMap[i] = -1
	}

	for len(stack) > 0 {
		var stackLen i32 = len(stack)

		stackLen--
		var node i32 = stack[stackLen]
		stack = resize(stack, stackLen)

		if node < 0 {
			matrixStack = mat.MatrixStackPop(matrixStack, 0-node)
		} else {
			var stackPushed i32
			var nodeIndex i32 = len(nodes)
			nodes = append(nodes, node)
			nodesMap[node] = nodeIndex
			//if options & MODEL_ANIMATION != 0 {
				var skeletonRoot i32 = g_models[modelIndex].skeleton.root
				if skeletonRoot == -1 {
					var skin gltf.Skin = gltf.NodeGetSkin(asset, node)
					if skin.inverseBindMatrices != -1 {
						var accessor gltf.Accessor = gltf.AssetGetAccessor(asset, skin.inverseBindMatrices)
						g_models[modelIndex].inverseBind = accessor.dataF32
						g_models[modelIndex].jointMatrices = resize(g_models[modelIndex].jointMatrices, len(accessor.dataF32))
					}
					g_models[modelIndex].skeleton.root = skin.skeleton
					g_models[modelIndex].skinned = skin.skeleton >= 0 // TODO : multiple skeleton per scene
					g_models[modelIndex].joints = skin.joints
				}
			//}

			var nodeMatrix []f32 = gltf.NodeGetMatrix(asset, node)
			var determinant f32 = mat.MatrixDeterminant(nodeMatrix)
			determinants = append(determinants, determinant)
			/*var cullFace i32 = gl.BACK
			if determinant < 0.0 {
				cullFace = gl.FRONT
			}*/
			if len(nodeMatrix) > 0 {
				matrixStack = mat.MatrixStackPush(matrixStack, nodeMatrix)
				stackPushed++
			}

			var last []f32 = mat.MatrixStackLast(matrixStack)
			for mi := 0; mi < 16; mi++ {
				transforms = append(transforms, last[mi])
			}

			//if options & MODEL_GEOMETRY != 0 {
				var mesh i32 = gltf.NodeGetMesh(asset, node)
				var gltfPrimitives []gltf.Primitive = gltf.MeshGetPrimitives(asset, mesh)
				var gltfPrimitiveCount i32 = len(gltfPrimitives)

				for p := 0; p < gltfPrimitiveCount; p++ {

					var render MeshId = InvalidMesh()

					var gltfPrimitive gltf.Primitive = gltfPrimitives[p]
					var gltfMaterial gltf.Material = gltf.AssetGetMaterial(asset, gltfPrimitive.material)
					var metallicRoughness gltf.MetallicRoughness = gltfMaterial.pbrMetallicRoughness

					var indicesIndex i32 = gltfPrimitive.indices
					var meshCacheCount i32 = len(meshCacheKey)
					var pp i32
					for pp = 0; pp < meshCacheCount; pp++ {
						if meshCacheKey[pp] == indicesIndex {
							render = meshCacheVal[pp]
							pp = meshCacheCount
						}
					}

					var cullFace i32 = gl.BACK
					if gltfMaterial.doubleSided == 1 {
						cullFace = NONE
					} else if determinant < 0.0 {
						cullFace = gl.FRONT
					}

					if IsValidMesh(render) == false {
						render = meshInstance(asset, gltfPrimitive)
						MeshSetCulling(render, gl.CCW, cullFace)
						meshCacheKey = append(meshCacheKey, indicesIndex)
						meshCacheVal = append(meshCacheVal, render)
					}

					if IsValidMesh(render) == false {
						success = false
						return
					}

					var meshMin mat.v3 = g_meshes[render.mesh].min
					meshMin = mat.v3_transform_point(meshMin, last)

					var meshMax mat.v3 = g_meshes[render.mesh].max
					meshMax = mat.v3_transform_point(meshMax, last)

					max = mat.v3_max(meshMax, max)
					min = mat.v3_min(meshMin, min)

					var primitive Primitive

					primitive.mesh = render
					primitive.node = node
					primitive.nodeIndex = nodeIndex
					primitive.baseTexture = loadTexture(asset, dataDir, metallicRoughness.baseColorTexture.index)
					primitive.metalRoughTexture = loadTexture(asset, dataDir, metallicRoughness.metallicRoughnessTexture.index)
					primitive.emissiveTexture = loadTexture(asset, dataDir, gltfMaterial.emissiveTexture.index)
					primitive.normalTexture = loadTexture(asset, dataDir, gltfMaterial.normalTexture.index)
					primitive.occlusionTexture = loadTexture(asset, dataDir, gltfMaterial.occlusionTexture.index)
					primitive.gltfMaterial = gltfMaterial
					primitive.gltfPrimitive = gltfPrimitive
					if MeshUseWeight(render) &&  MeshUseJoint(render) {
						primitive.useSkin = 1
					}

					var effect EffectId = effectInstance(&primitive)
					if EffectIsValid(effect) == false {
						printf("effectInstance failed\n")
						success = false
						return
					}
					primitive.effect = effect

					var primitiveIndex i32 = len(primitives)
					primitives = append(primitives, primitive)

					meshes = append(meshes, primitiveIndex)
					var alphaMode i32 = gltfMaterial.alphaMode
					if alphaMode == gltf.ALPHA_BLEND {
						transparentMeshes = append(transparentMeshes, primitiveIndex)
					} else if alphaMode == gltf.ALPHA_OPAQUE {
						opaqueMeshes = append(opaqueMeshes, primitiveIndex)
					}
				}
			//}

			var children []i32 = gltf.NodeGetChildren(asset, node)
			var childCount i32 = len(children)
			if stackPushed > 0 {
				stack = append(stack, 0-stackPushed)
			}
			if childCount > 0 {
				for i := 0; i < childCount; i++ {
					stack = append(stack, children[i])
				}
			}
		}
	}

	stack = resize(stack, 0)
	g_models[modelIndex].stack = stack
	g_models[modelIndex].nodes = nodes
	g_models[modelIndex].nodesMap = nodesMap
	g_models[modelIndex].determinants = determinants
	g_models[modelIndex].meshes = meshes
	g_models[modelIndex].primitives = primitives
	g_models[modelIndex].opaqueMeshes = opaqueMeshes
	g_models[modelIndex].transparentMeshes = transparentMeshes
	g_models[modelIndex].meshCacheKey = meshCacheKey
	g_models[modelIndex].meshCacheVal = meshCacheVal
	g_models[modelIndex].animations = animations
	g_models[modelIndex].matrixStack = resize(matrixStack, 0)
	g_models[modelIndex].transforms = transforms
	g_models[modelIndex].max = max
	g_models[modelIndex].min = min

	success = true
}



func AnimationMorph(left AnimationId, right AnimationId, out AnimationId, time f32) {
	panicIfNot(AnimationIsValid(left), "invalid animation")
	panicIfNot(AnimationIsValid(right), "invalid animation")
	panicIfNot(AnimationIsValid(out), "invalid animation")

	var leftIndex i32 = left.animation
	var trsLeft []f32 = g_animations[leftIndex].trs
	var animLeft []bool = g_animations[leftIndex].animated

	var rightIndex i32 = right.animation
	var trsRight []f32 = g_animations[rightIndex].trs
	var animRight []bool = g_animations[rightIndex].animated

	var outIndex i32 = out.animation
	var trsOut []f32 = g_animations[outIndex].trs
	var animOut []bool = g_animations[outIndex].animated

	var count i32 = len(trsLeft)
	panicIf(count != len(trsRight), "incompatible animations")
	panicIf((count % 10) != 0, "invalid TRS count")

	var nodeCount i32 = count / 10
	//time = 0.5
	var invt f32 = 1.0 - time

	trsOut = resize(trsOut, 0)
	animOut = resize(animOut, 0)
	for i := 0; i < nodeCount; i++ {
		var offset i32 = 10 * i
		var tx f32 = trsLeft[offset + 0] * invt + trsRight[offset + 0] * time
		var ty f32 = trsLeft[offset + 1] * invt + trsRight[offset + 1] * time
		var tz f32 = trsLeft[offset + 2] * invt + trsRight[offset + 2] * time

		var rx f32 = trsLeft[offset + 3] * invt + trsRight[offset + 3] * time
		var ry f32 = trsLeft[offset + 4] * invt + trsRight[offset + 4] * time
		var rz f32 = trsLeft[offset + 5] * invt + trsRight[offset + 5] * time
		var rw f32 = trsLeft[offset + 6] * invt + trsRight[offset + 6] * time
		//var r mat.v4 = mat.v4_(rx, ry, rz, rw)
		//var r mat.v4 = mat.v4_normalize(mat.v4_(rx, ry, rz, rw))
		var r mat.v4 = mat.QuaternionSlerp(
				mat.v4_(trsLeft[offset + 3], trsLeft[offset + 4], trsLeft[offset + 5], trsLeft[offset + 6]),
				mat.v4_(trsRight[offset + 3], trsRight[offset + 4], trsRight[offset + 5], trsRight[offset + 6]),
				time)
		var sx f32 = trsLeft[offset + 7] * invt + trsRight[offset + 7] * time
		var sy f32 = trsLeft[offset + 8] * invt + trsRight[offset + 8] * time
		var sz f32 = trsLeft[offset + 9] * invt + trsRight[offset + 9] * time
		trsOut = append(trsOut, tx)
		trsOut = append(trsOut, ty)
		trsOut = append(trsOut, tz)

		trsOut = append(trsOut, r.x)
		trsOut = append(trsOut, r.y)
		trsOut = append(trsOut, r.z)
		trsOut = append(trsOut, r.w)

		trsOut = append(trsOut, sx)
		trsOut = append(trsOut, sy)
		trsOut = append(trsOut, sz)

		animOut = append(animOut, animLeft[i])
		panicIf(animLeft[i] != animRight[i], "animated transform mismatch TRS vs matrix")
	}

	g_animations[outIndex].min = g_animations[leftIndex].min
	g_animations[outIndex].max = g_animations[leftIndex].max
	g_animations[outIndex].trs = trsOut
	g_animations[outIndex].animated = animOut
}

// AnimationGetMax ...
func AnimationGetMax(id AnimationId) (out f32) {
	panicIfNot(AnimationIsValid(id), "invalid model")
	out = g_animations[id.animation].max
}

// AnimationSetTime ...
func AnimationSetTime(id AnimationId, time f32) {
	panicIfNot(AnimationIsValid(id), "invalid animation")
	g_animations[id.animation].time = time
}

// AnimationGetJointTRS ...
func AnimationGetJointTRS(id AnimationId, joint i32) (t mat.v3, r mat.v4, s mat.v3) {
	panicIfNot(AnimationIsValid(id), "invalid animation")
	var trs []f32 = g_animations[id.animation].trs
	var offset i32 = joint * 10
	panicIf(offset + 10 >= len(trs), "invalid joint")
	t.x = trs[offset + 0]
	t.y = trs[offset + 1]
	t.z = trs[offset + 2]

	r.x = trs[offset + 3]
	r.y = trs[offset + 4]
	r.z = trs[offset + 5]
	r.w = trs[offset + 6]

	s.x = trs[offset + 7]
	s.y = trs[offset + 8]
	s.z = trs[offset + 9]
}

// AnimationSetJointTRS ...
func AnimationSetJointTRS(id AnimationId, joint i32, t mat.v3, r mat.v4, s mat.v3) {
	panicIfNot(AnimationIsValid(id), "invalid animation")
	var trs[]f32 = g_animations[id.animation].trs
	var offset i32 = joint * 10
	panicIf(offset + 10 >= len(trs), "invalid joint")
	trs[offset + 0] = t.x
	trs[offset + 1] = t.y
	trs[offset + 2] = t.z

	trs[offset + 3] = r.x
	trs[offset + 4] = r.y
	trs[offset + 5] = r.z
	trs[offset + 6] = r.w

	trs[offset + 7] = s.x
	trs[offset + 8] = s.y
	trs[offset + 9] = s.z
}

// AnimationGetJointRotation ...
func AnimationGetJointRotation(id AnimationId, joint i32) (out mat.v4) {
	panicIfNot(AnimationIsValid(id), "invalid animation")
	var trs []f32 = g_animations[id.animation].trs
	var offset i32 = joint * 10
	panicIf(offset + 10 >= len(trs), "invalid joint")
	out.x = trs[offset + 3]
	out.y = trs[offset + 4]
	out.z = trs[offset + 5]
	out.w = trs[offset + 6]
}

// AnimationSetJointRotation ...
func AnimationSetJointRotation(id AnimationId, joint i32, q mat.v4) {
	panicIfNot(AnimationIsValid(id), "invalid animation")
	var trs[]f32 = g_animations[id.animation].trs
	var offset i32 = joint * 10
	panicIf(offset + 10 >= len(trs), "invalid joint")
	trs[offset + 3] = q.x
	trs[offset + 4] = q.y
	trs[offset + 5] = q.z
	trs[offset + 6] = q.w
}

// AnimationUpdate ...
func AnimationUpdate(id AnimationId, deltaTime f32, loop bool, max f32) {
	panicIfNot(AnimationIsValid(id), "invalid model")
	var animIndex i32 = id.animation
	var animationCount i32 = len(g_animations)

	var animation Animation = g_animations[animIndex]
	var animMin f32 = animation.min
	var animMax f32 = animation.max
	if (max > 0.0) {
		animMax = max
	}

	var animDir f32 = animation.direction
	var animTime f32 = animation.time + animDir * deltaTime
	if animTime < animMin {
		if loop == true {
			animTime = animMax
		} else {
			animTime = animMin
			animDir = 1.0
		}
	}
	if animTime > animMax {
		if loop == true {
			animTime = 0.0//animMin
		} else {
			animTime = animMax
			animDir = -1.0
		}
	}
	var sources []AnimationSource = animation.sources
	var sourceCount i32 = len(sources)
	if sourceCount > 0 {
		animation.time = animTime
		animation.direction = animDir

		var animTrs []f32 = animation.trs
		animTrs = resize(animTrs, 0)

		var animated []bool = animation.animated
		animated = resize(animated, 0)

		var animAsset gltf.AssetId = animation.asset

		var samplers []gltf.AnimationSampler = animation.samplers
		var channels []gltf.AnimationChannel = animation.channels
		var indices []i32 = animation.indices

		for sourceIndex := 0; sourceIndex < sourceCount; sourceIndex++ {

			var nodeTranslation mat.v3 = gltf.NodeGetTranslation(animAsset, sourceIndex)
			var nodeRotation mat.v4 = gltf.NodeGetRotation(animAsset, sourceIndex)
			var nodeScale mat.v3 = gltf.NodeGetScale(animAsset, sourceIndex)

			var source AnimationSource = sources[sourceIndex]
			var nodeChannelCount i32 = source.count
			if nodeChannelCount > 0 {

				var anim bool
				var useTX i32
				var useRX i32
				var useSX i32
				var animTranslation v3 = mat.v3_(0.0, 0.0, 0.0)
				var animRotation v4 = mat.v4_(0.0, 0.0, 0.0, 1.0)
				var animScale v3 = mat.v3_(1.0, 1.0, 1.0)
				var nodeChannelOffset i32 = source.offset

				for channelIndex := 0; channelIndex < nodeChannelCount; channelIndex++ {
					var nodeChannelIndex i32 = indices[nodeChannelOffset + channelIndex]
					var channel gltf.AnimationChannel = channels[nodeChannelIndex] // ISSUE : no index out of range if channels is not initialized

					var index i32 = -1
					var inputAccessor gltf.Accessor = gltf.AssetGetAccessor(animAsset, samplers[channel.sampler].inputA)
					var inputs []f32 = inputAccessor.dataF32
					var inputCount i32 = len(inputs)
					for t := 0; t < inputCount; t++ { // TODO : track time
						if animTime <= inputs[t] {
							index = t
							t = inputCount // ISSUE : break
						}
					}

					if index >= inputCount {
						index = inputCount - 1
					}
					if index < 0 {
						index = 0
					}

					var prev i32 = index - 1
					if prev < 0 {
						prev = 0
					}

					var delta f32 = animTime - inputs[prev]
					var step f32 = inputs[index] - inputs[prev]
					var st f32 = 1.0;
					if step > 0.0 {
						st = delta / step
					}
					var t f32 = st
					if t < 0.0 {
						t = 0.0
					} else if t > 1.0 {
						t = 1.0
					}

					var outputAccessor gltf.Accessor = gltf.AssetGetAccessor(animAsset, samplers[channel.sampler].outputA)
					var outputs []f32 = outputAccessor.dataF32
					var path i32 = channel.path
					if path == gltf.ANIMATION_PATH_TRANSLATION {
						panicIf(outputAccessor.attributeTypeEnum != gltf.TYPE_VEC3, "invalid attribute type")
						panicIf(outputAccessor.componentType != gl.FLOAT, "unhandled component type")
						var x0 f32 = outputs[prev * 3 + 0]
						var y0 f32 = outputs[prev * 3 + 1]
						var z0 f32 = outputs[prev * 3 + 2]

						var x1 f32 = outputs[index * 3 + 0]
						var y1 f32 = outputs[index * 3 + 1]
						var z1 f32 = outputs[index * 3 + 2]

						var x f32 = x0 + (x1 - x0) * t
						var y f32 = y0 + (y1 - y0) * t
						var z f32 = z0 + (z1 - z0) * t

						anim = true
						animTranslation = mat.v3_(x, y, z)
						useTX = 1
					} else if path == gltf.ANIMATION_PATH_ROTATION {
						panicIf(outputAccessor.attributeTypeEnum != gltf.TYPE_VEC4, "invalid attribute type")
						panicIf(outputAccessor.componentType != gl.FLOAT, "unhandled component type")
						var x0 f32 = outputs[prev * 4 + 0]
						var y0 f32 = outputs[prev * 4 + 1]
						var z0 f32 = outputs[prev * 4 + 2]
						var w0 f32 = outputs[prev * 4 + 3]

						var x1 f32 = outputs[index * 4 + 0]
						var y1 f32 = outputs[index * 4 + 1]
						var z1 f32 = outputs[index * 4 + 2]
						var w1 f32 = outputs[index * 4 + 3]

						var x f32 = x0 + (x1 - x0) * t
						var y f32 = y0 + (y1 - y0) * t
						var z f32 = z0 + (z1 - z0) * t
						var w f32 = w0 + (w1 - w0) * t

						//var q mat.v4 = mat.QuaternionSlerp(
						//		mat.v4_normalize(mat.v4_(x0, y0, z0, w0)),
						//		mat.v4_normalize(mat.v4_(x1, y1, z1, w1)), t)
						var q mat.v4 = mat.v4_normalize(mat.v4_(x, y, z, w))

						animRotation = q
						anim = true
						useRX = 1
					} else if path == gltf.ANIMATION_PATH_SCALE {
						panicIf(outputAccessor.attributeTypeEnum != gltf.TYPE_VEC3, "invalid attribute type")
						panicIf(outputAccessor.componentType != gl.FLOAT, "unhandled component type")
						var x0 f32 = outputs[prev * 3 + 0]
						var y0 f32 = outputs[prev * 3 + 1]
						var z0 f32 = outputs[prev * 3 + 2]

						var x1 f32 = outputs[index * 3 + 0]
						var y1 f32 = outputs[index * 3 + 1]
						var z1 f32 = outputs[index * 3 + 2]

						var x f32 = x0 + (x1 - x0) * t
						var y f32 = y0 + (y1 - y0) * t
						var z f32 = z0 + (z1 - z0) * t

						animScale = mat.v3_(x, y, z)
						useSX = 1
						anim = true
					} else if path == gltf.ANIMATION_PATH_WEIGHTS {
					} else {
						panicIf(true, "invalid animation path")
					}
				}

				if useTX != 0 {
					nodeTranslation = animTranslation
				}
				if useRX != 0 {
					nodeRotation = animRotation
				}
				if useSX == 0 {
					nodeScale = animScale
				}

				sources[sourceIndex] = source
				panicIf(gltf.NodeHasMatrix(animAsset, sourceIndex), "matrix transform with animation is not implemented")
				animated = append(animated, true)
			} else {
				animated = append(animated, false)
			}

			animTrs = append(animTrs, nodeTranslation.x)
			animTrs = append(animTrs, nodeTranslation.y)
			animTrs = append(animTrs, nodeTranslation.z)

			animTrs = append(animTrs, nodeRotation.x)
			animTrs = append(animTrs, nodeRotation.y)
			animTrs = append(animTrs, nodeRotation.z)
			animTrs = append(animTrs, nodeRotation.w)

			animTrs = append(animTrs, nodeScale.x)
			animTrs = append(animTrs, nodeScale.y)
			animTrs = append(animTrs, nodeScale.z)
		}

		animation.trs = animTrs
		animation.animated = animated
	}
	g_animations[animIndex] = animation
}



func debugNode(stackCount i32, asset gltf.AssetId, node i32) {
	for kk := 0; kk < stackCount; kk++ {
		printf("--")
	}

	printf("%s :\n", gltf.NodeGetName(asset, node))
}

func modelTransform(id ModelId, animId AnimationId, deltaTime f32, loop bool) {
	panicIfNot(ModelIsValid(id), "invalid model")

	var modelIndex i32 = id.model
	var animIndex i32 = animId.animation

	var animationCount i32 = len(g_animations)
	if animIndex >= 0 && animIndex < animationCount {
		var animated bool = g_models[modelIndex].animated
		var skinned bool = g_models[modelIndex].skinned
		if animated || skinned {
			var identity []f32 = g_models[modelIndex].identity
			var tmp []f32 = g_models[modelIndex].tmp
			var tmp2 []f32 = g_models[modelIndex].tmp2
			var modelAsset gltf.AssetId = g_models[modelIndex].asset

			var animation Animation = g_animations[animIndex]
			var animTrs []f32 = animation.trs
			var animNode []bool = animation.animated
			var animTransforms []f32 = animation.transforms
			animTransforms = resize(animTransforms, 0)
			var trsCount i32 = len(animTrs)
			if trsCount > 0 {
				var nodeCount i32 = trsCount / 10
				for node := 0; node < nodeCount; node++ {

					var nodeMatrix []f32 = gltf.NodeGetMatrix(modelAsset, node)
					if animNode[node] == true {
						var offset i32 = node * 10
						var tx f32 = animTrs[offset + 0]
						var ty f32 = animTrs[offset + 1]
						var tz f32 = animTrs[offset + 2]

						var rx f32 = animTrs[offset + 3]
						var ry f32 = animTrs[offset + 4]
						var rz f32 = animTrs[offset + 5]
						var rw f32 = animTrs[offset + 6]

						var sx f32 = animTrs[offset + 7]
						var sy f32 = animTrs[offset + 8]
						var sz f32 = animTrs[offset + 9]

						tmp = mat.MatrixCreate2(tmp, sx, sy, sz, rx, ry, rz, rw, tx, ty, tz)
						for mi := 0; mi < 16; mi++ {
							animTransforms = append(animTransforms, tmp[mi])
						}
					} else {
						for mi := 0; mi < 16; mi++ {
							animTransforms = append(animTransforms, nodeMatrix[mi])
						}
					}
				}

				g_animations[animIndex].transforms = animTransforms

				var transforms []f32 = g_models[modelIndex].transforms
				transforms = resize(transforms, 0)

				var matrixStack []f32 = g_models[modelIndex].matrixStack
				matrixStack = resize(matrixStack, 0)
				matrixStack = mat.MatrixStackPush(matrixStack, identity)

				var stack []i32 = g_models[modelIndex].stack

				var roots []i32 = gltf.AssetGetRootNodes(modelAsset)
				var rootCount i32 = len(roots)
				stack = resize(stack, rootCount)
				for i := 0; i < rootCount; i++ {
					stack[i] = roots[i]
				}

				var animTransformCount i32 = len(animTransforms) / 16
				panicIf(animTransformCount != nodeCount, "internal error")

				var stackCount i32
				for len(stack) > 0 {
					var stackLen i32 = len(stack)

					stackLen--
					var node i32 = stack[stackLen]

					stack = resize(stack, stackLen)
					if node < 0 {
						stackCount = stackCount - 1
						matrixStack = mat.MatrixStackPop(matrixStack, 1)
					} else {
						stackCount = stackCount + 1
						var stackPushed i32 = 0

						if node < animTransformCount {
							for mi := 0; mi < 16; mi++ {
								tmp2[mi] = animTransforms[node * 16 + mi]
							}
						} else {
							var nodeMatrix []f32 = gltf.NodeGetMatrix(modelAsset, node)
							for mi := 0; mi < 16; mi++ {
								tmp2[mi] = nodeMatrix[mi]
							}
						}

						matrixStack = mat.MatrixStackPush(matrixStack, tmp2)

						var last []f32 = mat.MatrixStackLast(matrixStack)
						for mi := 0; mi < 16; mi++ {
							transforms = append(transforms, last[mi])
						}

						var children []i32 = gltf.NodeGetChildren(modelAsset, node)
						var childCount i32 = len(children)
						stack = append(stack, -1)
						if childCount > 0 {
							for i := 0; i < childCount; i++ {
								stack = append(stack, children[i])
							}
						}
					}
				}

				g_models[modelIndex].stack = resize(stack, 0)
				g_models[modelIndex].matrixStack = resize(matrixStack, 0)
				g_models[modelIndex].transforms = transforms
			}
		}
	}

	var joints []i32 = g_models[modelIndex].joints
	if len(joints) > 0 {
		var jointMatrices []f32 = g_models[modelIndex].jointMatrices
		var inverseBind []f32 = g_models[modelIndex].inverseBind
		var nodesMap []i32 = g_models[modelIndex].nodesMap
		var transforms []f32 = g_models[modelIndex].transforms
		var tmp []f32 = g_models[modelIndex].tmp
		var tmp2 []f32 = g_models[modelIndex].tmp2
		for j := 0; j < len(joints); j++ {
			var node i32 = joints[j]
			var nodeIndex i32 = nodesMap[node]
			var nodeOffset i32 = nodeIndex * 16
			for mi := 0; mi < 16; mi++ {
				tmp2[mi] = transforms[nodeOffset + mi]
			}

			var joffset i32 = j * 16
			for mi := 0; mi < 16; mi++ {
				tmp[mi] = inverseBind[joffset + mi]
			}

			tmp = mat.MatrixMultiply(tmp, tmp, tmp2)

			for mi := 0; mi < 16; mi++ {
				jointMatrices[joffset + mi] = tmp[mi]
			}
		}
	}
}

// ModelGetMeshes ...
func ModelGetMeshes(id ModelId) (out []i32) {
	panicIfNot(ModelIsValid(id), "invalid model")
	out = g_models[id.model].meshes
}

// ModelGetNodePosition ...
func ModelGetNodePosition(id ModelId, node i32) (out mat.v3) {
	panicIfNot(ModelIsValid(id), "invalid model")
	var modelIndex i32 = id.model
	var nodesMap []i32 = g_models[modelIndex].nodesMap
	var nodeIndex i32 = nodesMap[node]
	var offset i32 = nodeIndex * 16
	var transforms []f32 = g_models[modelIndex].transforms
	out.x = transforms[offset +12]
	out.y = transforms[offset +13]
	out.z = transforms[offset +14]
}

// ModelGetNodeTransform ...
func ModelGetNodeTransform(id ModelId, node i32, in []f32) (out []f32) {
	out = in
	panicIfNot(ModelIsValid(id), "invalid model")
	var modelIndex i32 = id.model
	var nodesMap []i32 = g_models[modelIndex].nodesMap
	var nodeIndex i32 = nodesMap[node]
	var offset i32 = nodeIndex * 16
	var transforms []f32 = g_models[modelIndex].transforms
	out[ 0] = transforms[offset + 0]
	out[ 1] = transforms[offset + 1]
	out[ 2] = transforms[offset + 2]
	out[ 3] = transforms[offset + 3]
	out[ 4] = transforms[offset + 4]
	out[ 5] = transforms[offset + 5]
	out[ 6] = transforms[offset + 6]
	out[ 7] = transforms[offset + 7]
	out[ 8] = transforms[offset + 8]
	out[ 9] = transforms[offset + 9]
	out[10] = transforms[offset +10]
	out[11] = transforms[offset +11]
	out[12] = transforms[offset +12]
	out[13] = transforms[offset +13]
	out[14] = transforms[offset +14]
	out[15] = transforms[offset +15]
}


func modelRender(id ModelId, renderables []i32, alpha f32) {
	panicIfNot(ModelIsValid(id), "invalid model")

	var modelIndex i32 = id.model
	var tmp []f32 = g_models[modelIndex].tmp
	var world []f32 = g_models[modelIndex].world
	var transforms []f32 = g_models[modelIndex].transforms
	var primitives []Primitive = g_models[modelIndex].primitives

	var environmentSpecular TextureId = g_models[modelIndex].environmentSpecular
	var environmentDiffuse TextureId = g_models[modelIndex].environmentDiffuse
	var brdf TextureId = g_models[modelIndex].brdf

	var view []f32 = g_models[modelIndex].view
	var projection []f32 = g_models[modelIndex].projection
	var jointMatrices []f32 = g_models[modelIndex].jointMatrices
	var color []f32 = color = g_models[modelIndex].color
	var cameraPosition []f32 = g_models[modelIndex].cameraPosition

	var renderableCount i32 = len(renderables)

	for p := 0; p < renderableCount; p++ {
		var renderable i32 = renderables[p]
		var primitive Primitive = primitives[renderable]//renderables[p]]
		var effect EffectId = effectInstance(&primitive)

		EffectTryAssignTexture(effect, SAMPLER_COLOR_0, primitive.baseTexture, g_linearWrap) // TODO : use gltf sampler
		EffectTryAssignTexture(effect, SAMPLER_NORMAL, primitive.normalTexture, g_linearWrap) // TODO : use gltf sampler
		EffectTryAssignTexture(effect, SAMPLER_METAL_ROUGH, primitive.metalRoughTexture, g_linearWrap) // TODO : use gltf sampler
		EffectTryAssignTexture(effect, SAMPLER_ENV_SPECULAR, environmentSpecular, g_linearWrap) // TODO : use gltf sampler
		EffectTryAssignTexture(effect, SAMPLER_ENV_DIFFUSE, environmentDiffuse, g_linearWrap) // TODO : use gltf sampler
		EffectTryAssignTexture(effect, SAMPLER_BRDF, brdf, g_linear0Wrap) // TODO : use gltf sampler
		EffectTryAssignTexture(effect, SAMPLER_EMISSIVE, primitive.emissiveTexture, g_linearWrap) // TODO : use gltf sampler
		EffectTryAssignTexture(effect, SAMPLER_OCCLUSION, primitive.occlusionTexture, g_linearWrap) // TODO : use gltf sampler

		var skinned bool = g_models[modelIndex].skinned
		if skinned == true {
			for ii := 0; ii < 16; ii++ {
				tmp[ii] = world[ii]
			}
		} else {
			var nodeIndex i32 = primitive.nodeIndex
			var mi i32 // ISSUE : can't use short declaration here
			for mi = 0; mi < 16; mi++ {
				tmp[mi] = transforms[nodeIndex * 16 + mi]
			}
			tmp = mat.MatrixMultiply(tmp, tmp, world)
		}

		EffectAssignMatrix4(effect, UNIFORM_WORLD, tmp, false)
		EffectAssignMatrix4(effect, UNIFORM_VIEW, view, false)
		EffectAssignMatrix4(effect, UNIFORM_PROJECTION, projection, false)

		tmp = mat.MatrixInverse(tmp, tmp)
		EffectAssignMatrix4(effect, UNIFORM_WORLD_INVERSE, tmp, false)
		if primitive.useSkin == 1 {
	  		EffectAssignMatrix4(effect, UNIFORM_SKELETON, jointMatrices, false)
		}

		var metallicRoughness gltf.MetallicRoughness = primitive.gltfMaterial.pbrMetallicRoughness
		if EffectIsValidUniformLocation(effect, UNIFORM_COLOR) {
	  		var baseColorFactor [4]f32
	  		baseColorFactor = metallicRoughness.baseColorFactor
	  		color[0] = baseColorFactor[0]
	  		color[1] = baseColorFactor[1]
	  		color[2] = baseColorFactor[2]
	  		color[3] = baseColorFactor[3] * alpha
	  		EffectAssignVector4(effect, UNIFORM_COLOR, color)
		}

		if EffectIsValidUniformLocation(effect, UNIFORM_METAL_ROUGH) {
	  		color[0] = 0.0
	  		color[1] = metallicRoughness.roughnessFactor
	  		color[2] = metallicRoughness.metallicFactor
	  		color[3] = 0.0
	  		EffectAssignVector4(effect, UNIFORM_METAL_ROUGH, color)
		}

		if EffectIsValidUniformLocation(effect, UNIFORM_EMISSIVE) {
	  		var emissiveFactor [4]f32
	  		color[0] = emissiveFactor[0]
	  		color[1] = emissiveFactor[1]
	  		color[2] = emissiveFactor[2]
	  		color[3] = emissiveFactor[3]
	  		EffectAssignVector4(effect, UNIFORM_EMISSIVE, color)
		}

		EffectAssignVector4(effect, UNIFORM_CAMERA_POSITION, cameraPosition)
		EffectAssignVector4(effect, UNIFORM_DEBUG_0, DEBUG_0)

		MeshRender(primitive.mesh)
	}
}
