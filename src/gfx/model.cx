package gfx

import "gltf"

// Globals ...
var g_models []Model

// Animation ...
type Animation struct {
	channel gltf.AnimationChannel
	sampler gltf.AnimationSampler
	index i32
	time f32
	direction f32
	min f32
	max f32
}

type Skeleton struct {
}

type Primitive struct {
	mesh MeshId
	node i32
	nodeIndex i32

	effect EffectId

	useSkin i32
	baseTexture TextureId
	metalRoughTexture TextureId
	emissiveTexture TextureId
	normalTexture TextureId
	occlusionTexture TextureId

	gltfPrimitive gltf.Primitive
	gltfMaterial gltf.Material
}

func effectInstance(primitive *Primitive) (out EffectId) {
	var mesh MeshId = primitive.mesh

	var useColorVtx bool = MeshUseColor(mesh)
	var useColorMap bool = IsValidTexture(primitive.baseTexture)
	var useColorUni bool = useColorMap == false

	var usePbrMap bool = IsValidTexture(primitive.metalRoughTexture)
	var usePbrUni bool = usePbrMap == false

	var useEmissiveMap bool = IsValidTexture(primitive.emissiveTexture)
	var useEmissiveUni bool = useEmissiveMap == false

	var useNormalMap bool = IsValidTexture(primitive.normalTexture)
	var useNormalVtx bool = MeshUseNormal(mesh)
	var useTangentVtx bool = MeshUseTangent(mesh)

	var useOcclusionTexture bool = IsValidTexture(primitive.occlusionTexture)

	var useWeights bool = MeshUseWeight(mesh)
	var useJoints bool = MeshUseJoint(mesh)
	var useSkin bool = useWeights && useJoints

	TemplateSetKey(g_tfxPbr, USE_COLOR_UNI, useColorUni)
	TemplateSetKey(g_tfxPbr, USE_COLOR_VTX, useColorVtx)
	TemplateSetKey(g_tfxPbr, USE_COLOR_MAP, useColorMap)

	TemplateSetKey(g_tfxPbr, USE_PBR_UNI, usePbrUni)
	TemplateSetKey(g_tfxPbr, USE_PBR_MAP, usePbrMap)

	TemplateSetKey(g_tfxPbr, USE_EMISSIVE_UNI, useEmissiveUni)
	TemplateSetKey(g_tfxPbr, USE_EMISSIVE_MAP, useEmissiveMap)

	TemplateSetKey(g_tfxPbr, USE_NORMAL_VTX, useNormalVtx)
	TemplateSetKey(g_tfxPbr, USE_NORMAL_MAP, useNormalMap)
	TemplateSetKey(g_tfxPbr, USE_TANGENT_VTX, useTangentVtx)

	TemplateSetKey(g_tfxPbr, USE_OCCLUSION_MAP, useOcclusionTexture)

	TemplateSetKey(g_tfxPbr, USE_SKIN, useSkin)

	TemplateSetKey(g_tfxPbr, USE_DEBUG_A, true)

	out = TemplateInstance(g_tfxPbr)
}

// ModelId ...
type ModelId struct {
	model i32
}

// Model ...
type Model struct {
	stack []i32
	asset gltf.AssetId
	animated bool

	min mat.v3
	max mat.v3

	meshes []MeshId

	identity []f32
	world []f32
	view []f32 // TODO : remove
	projection []f32 // TODO : remove
	color []f32
	dataDir str
	filename str
	matrixStack []f32
	tmp []f32 // TODO : remove
	environmentSpecular TextureId
	environmentDiffuse TextureId
	brdf TextureId
	cameraPosition []f32

	nodes[]i32
	determinants []f32
	transforms []f32

	primitives []Primitive
	opaqueMeshes []i32
	transparentMeshes []i32

	animations []Animation
	animationIndices []i32
	animationCounts []i32
	meshCacheKey []i32
	meshCacheVal []MeshId
	animation []f32 // TODO : remove
	inverseBind []f32 // TODO : skeleton struct
	skeletonRoot i32 // TODO : skeleton struct
	joints []i32 // TODO : skeleton struct
	jointMatrices []f32 // TODO : runtime struct
	tmp2 []f32
}

// ModelIsValid ...
func ModelIsValid(id ModelId) (out bool) {
	out = id.model >= 0 && id.model < len(g_models)
}

// ModelInvalid ...
func ModelInvalid() (out ModelId) {
	out.model = -1
}

// ModelCreateFromFile ...
func ModelCreateFromFile(dataDir str, filename str) (out ModelId){
	out.model = len(g_models)

	var model Model
	model.color = resize(model.color, 4)
	model.color[0] = 1.0
	model.color[1] = 0.0
	model.color[2] = 1.0
	model.color[3] = 1.0
	model.dataDir = dataDir
	model.filename = filename
	model.asset = gltf.AssetCreate(dataDir, filename)
	if gltf.AssetIsValid(model.asset) == false {
		printf("gltf.AssetCreate failed\n")
		out = ModelInvalid()
		return
	}

	var tmp []f32 = mat.MatrixAlloc()
	model.tmp = tmp

	var tmp2 []f32 = mat.MatrixAlloc()
	model.tmp2 = tmp2

	var world []f32 = mat.MatrixAlloc()
	model.world = world

	var view []f32 = mat.MatrixAlloc()
	model.view = view

	var projection []f32 = mat.MatrixAlloc()
	model.projection = projection

	var animation []f32 = mat.MatrixAlloc()
	model.animation = animation

	var identity []f32 = mat.MatrixAlloc()
	model.identity = mat.MatrixIdentity(identity)

	model.skeletonRoot = -1

	//gltf.AssetPrint(model.asset)

	g_models = append(g_models, model)

	if modelInstance(out) == false {
		printf("modelInstance failed\n")
		out = ModelInvalid()
		return
	}

	modelUpdate(out, 0.0, false)
}

// ModelGetMin ...
func ModelGetMin(id ModelId) (out mat.v3) {
	panicIfNot(ModelIsValid(id), "invalid model")
	out = g_models[id.model].min
}

// ModelGetMax ...
func ModelGetMax(id ModelId) (out mat.v3) {
	panicIfNot(ModelIsValid(id), "invalid model")
	out = g_models[id.model].max
}

type channelInfo struct {
	count i32
	dataType i32
	dataLen i32
	dataF32 []f32
	dataUI8 []ui8
	dataUI16 []ui16
	dataUI32 []ui32
}

func meshInstance(id gltf.AssetId, primitive gltf.Primitive) (out MeshId) {
	var mode i32
	//printf("instancing : mode %d, indices %d, material %d\n", primitive.mode, primitive.indices, primitive.material)
	if primitive.mode == gltf.PRIMITIVE_LINES {
		mode = gl.LINES
	} else if primitive.mode == gltf.PRIMITIVE_TRIANGLES {
		mode = gl.TRIANGLES
	} else {
		printf("primitive type not implemented\n")
		out = InvalidMesh()
		return
	}

	var min mat.v3
	var max mat.v3

	var usePosition bool
	var useNormal bool
	var useColor bool
	var useTexcoord bool
	var useTangent bool
	var useWeight bool
	var useJoint bool

	// attributes
	var channels []channelInfo
	var attributes []VertexAttribute
	var vertexCount i32 = 0
	var attributeCount i32 = len(primitive.attributes)
	var byteStride i32 = 0
	var componentStride i32 = 0
	for a := 0; a < attributeCount; a++ {
		var accessor gltf.Accessor = gltf.AssetGetAccessor(id, primitive.attributes[a].accessor)
		if a > 0 && accessor.count != vertexCount {
			printf("wrong number of vectices\n")
			out = InvalidMesh()
			return
		}

		vertexCount = accessor.count

   		var channel channelInfo
		var attribute VertexAttribute

		if accessor.componentType == gl.FLOAT { // TODO : how to pass []struct to BufferData ?
			channel.dataF32 = accessor.dataF32
			channel.dataLen = len(channel.dataF32)
   			channel.dataType = gl.FLOAT
			attribute.componentType = gl.FLOAT
			attribute.componentByteSize = g_sizeofF32
		} else if accessor.componentType == gl.UNSIGNED_SHORT {
			channel.dataUI16 = accessor.dataUI16
			channel.dataLen = len(channel.dataUI16)
   			channel.dataType = gl.UNSIGNED_SHORT
			attribute.componentType = gl.UNSIGNED_SHORT
			attribute.componentByteSize = g_sizeofUI16
		} else if accessor.componentType == gl.UNSIGNED_INT {
			channel.dataUI32 = accessor.dataUI32
			channel.dataLen = len(channel.dataUI32)
			channel.dataType = gl.UNSIGNED_INT
			attribute.componentType = gl.UNSIGNED_INT
			attribute.componentByteSize = g_sizeofUI32
		} else {
			printf("buffer type not implemented %d\n", accessor.componentType)
			out = InvalidMesh()
			return
		}

		attribute.componentCount = accessor.componentCount
		attribute.componentOffset = componentStride
		attribute.byteOffset = byteStride

		var attributeType i32 = primitive.attributes[a].attributeType
		var binding i32 = -1
		if attributeType == gltf.ATTRIBUTE_POSITION {
			binding = ATTRIBUTE_POSITION
			min.x = accessor.min[0]
			min.y = accessor.min[1]
			min.z = accessor.min[2]
			max.x = accessor.max[0]
			max.y = accessor.max[1]
			max.z = accessor.max[2]
		} else if attributeType == gltf.ATTRIBUTE_NORMAL {
			binding = ATTRIBUTE_NORMAL
			useNormal = true
		} else if attributeType == gltf.ATTRIBUTE_COLOR {
			binding = ATTRIBUTE_COLOR
			useColor = true
		} else if attributeType == gltf.ATTRIBUTE_TEXCOORD {
			binding = ATTRIBUTE_TEXCOORD
			useTexcoord = true
		} else if attributeType == gltf.ATTRIBUTE_TANGENT {
			binding = ATTRIBUTE_TANGENT
			useTangent = true
		} else if attributeType == gltf.ATTRIBUTE_WEIGHT {
			binding = ATTRIBUTE_WEIGHT
			useWeight = true
		} else if attributeType == gltf.ATTRIBUTE_JOINT {
			binding = ATTRIBUTE_JOINT
			useJoint = true
		}

		attribute.binding = binding
		channel.count = attribute.componentCount

		attributes = append(attributes, attribute)
		channels = append(channels, channel)

		byteStride = byteStride + attribute.componentCount * attribute.componentByteSize
		componentStride = componentStride + attribute.componentCount
	}

	var vertexLen i32 = componentStride * vertexCount
	if vertexLen <= 0 {
		printf("invalid vertex buffer\n")
		out = InvalidMesh()
		return
	}

	// vertices // TODO : generate buffers from go data ?
	var vertices []ui8 // TODO : test perf with loop reordering + resize(vertices, vertexLen)
	for v := 0; v < vertexCount; v++ {
		for c := 0; c < attributeCount; c++ {
			var dataType i32 = channels[c].dataType
			var dataLen i32 = channels[c].dataLen
			var count i32 = channels[c].count
			var offset i32 = v * count
			if dataType == gl.FLOAT {
				var data []f32 = channels[c].dataF32
				for i := 0; i < count; i++ {
					vertices = gl.AppendF32(vertices, data[offset + i])
				}
			} else if dataType == gl.UNSIGNED_SHORT {
				var data []ui16 = channels[c].dataUI16
				for i := 0; i < count; i++ {
					vertices = gl.AppendUI16(vertices, data[offset + i])
				}
			} else if dataType == gl.UNSIGNED_INT {
				var data []ui32 = channels[c].dataUI32
				for i := 0; i < count; i++ {
					vertices = gl.AppendUI32(vertices, data[offset + i])
				}
			} else {
				panicIf(true, "unhandled dataType")
			}
		}
	}

	// indices
	var indices []ui8
	var indicesAccessor gltf.Accessor = gltf.AssetGetAccessor(id, primitive.indices)
	var indicesType i32 = indicesAccessor.componentType
	if indicesAccessor.componentCount != 1 ||
	   (indicesAccessor.componentType != gl.UNSIGNED_SHORT && indicesAccessor.componentType != gl.UNSIGNED_INT) ||
	   indicesAccessor.attributeTypeEnum != gltf.TYPE_SCALAR {
		printf("invalid index buffer format : componentCount %d, componentType %d, attributeType %d\n",
			indicesAccessor.componentCount, indicesAccessor.componentType, indicesAccessor.attributeTypeEnum)
		out = InvalidMesh()
		return
	}

	var indexByteCount i32 = 0
	if indicesType == gl.UNSIGNED_SHORT {
		var data []ui16 = indicesAccessor.dataUI16
		var count i32 = len(data)
		indexByteCount = 2
		for i := 0; i < count; i++ {
			indices = gl.AppendUI16(indices, data[i])
		}
	} else if indicesType == gl.UNSIGNED_INT {
		var data []ui32 = indicesAccessor.dataUI32
		var count i32 = len(data)
		indexByteCount = 4
		for i := 0; i < count; i++ {
			indices = gl.AppendUI32(indices, data[i])
		}
	} else {
		printf("invalid index buffer type\n")
		out = InvalidMesh()
		return
	}

	if len(attributes) > 0 && len(indices) > 0 && len(vertices) > 0 {
		out = MeshCreate(mode, indicesType, len(indices) / indexByteCount, attributes, len(vertices) / byteStride) // TODO : use real index/vertex count instead of bytecount
		MeshBegin(out) // TODO : remove MeshBegin/MeshEnd, data should be uploaded with BufferData in MeshInstance.
		g_meshes[out.mesh].vertices = vertices
		g_meshes[out.mesh].indices = indices
		g_meshes[out.mesh].usePosition = usePosition
		g_meshes[out.mesh].useNormal = useNormal
		g_meshes[out.mesh].useColor = useColor
		g_meshes[out.mesh].useTexcoord = useTexcoord
		g_meshes[out.mesh].useTangent = useTangent
		g_meshes[out.mesh].useWeight = useWeight
		g_meshes[out.mesh].useJoint = useJoint
		g_meshes[out.mesh].min = min
		g_meshes[out.mesh].max = max
		MeshEnd(out)
	}
}

// ModelSetCameraPosition ...
func ModelSetCameraPosition(id ModelId, position mat.v3) {
	panicIfNot(ModelIsValid(id), "invalid model")
	var cameraPosition []f32 = g_models[id.model].cameraPosition
	cameraPosition = resize(cameraPosition, 4)
	cameraPosition[0] = position.x
	cameraPosition[1] = position.y
	cameraPosition[2] = position.z
	cameraPosition[3] = 1.0
	g_models[id.model].cameraPosition = cameraPosition
}


// ModelSetEnvironmentSpecular ...
func ModelSetEnvironmentSpecular(id ModelId, environment TextureId) { 
	panicIfNot(ModelIsValid(id), "invalid model")
	g_models[id.model].environmentSpecular = environment
}

// ModelSetEnvironmentDiffuse...
func ModelSetEnvironmentDiffuse(id ModelId, environment TextureId) { 
	panicIfNot(ModelIsValid(id), "invalid model")
	g_models[id.model].environmentDiffuse = environment
}

// ModelSetBRDF ...
func ModelSetBRDF(id ModelId, brdf TextureId) {
	panicIfNot(ModelIsValid(id), "invalid model")
	g_models[id.model].brdf = brdf
}

// ModelSetWorld ...
func ModelSetWorld(id ModelId, world []f32) {
	panicIfNot(ModelIsValid(id), "invalid model")
	var i i32 = copy(g_models[id.model].world, world)
}

// ModelSetView ...
func ModelSetView(id ModelId, view []f32) {
	panicIfNot(ModelIsValid(id), "invalid model")
	var i i32 = copy(g_models[id.model].view, view)
}

// ModelSetProjection ...
func ModelSetProjection(id ModelId, projection []f32) {
	panicIfNot(ModelIsValid(id), "invalid model")
	var i i32 = copy(g_models[id.model].projection, projection)
}

func loadTexture(asset AssetId, dataDir str, index i32) (out TextureId) {
	out = InvalidTexture()
	//if gltf.AssetIsValidTexture(asset, index) {
		var texture gltf.Texture = gltf.AssetGetTexture(asset, index)
		var image gltf.Image = gltf.AssetGetImage(asset, texture.source)
		if image.uri != "" {
			out = TextureCreate(sprintf("%s%s", dataDir, image.uri), FORMAT_R8_G8_B8_A8, 0, 0, -1, false)
		}
	//}
}

// ModelUpdate ...
func ModelUpdate(id ModelId, deltaTime f32, loop bool) {
	panicIfNot(ModelIsValid(id), "invalid model")
	if g_models[id.model].animated {
		modelUpdate(id, deltaTime, loop)
	}
}

// ModelRender ...
func ModelRender(id ModelId) {
	DisableBlending()
	DepthState(true, LESS, true)
	modelRender(id, false)

	EnableBlending(SRC_ALPHA, ONE_MINUS_SRC_ALPHA)
	DepthState(true, LESS, true)
	modelRender(id, true)
}


func modelInstance(id ModelId) (success bool) {
	panicIfNot(ModelIsValid(id), "invalid model")

	var stack []i32 = g_models[id.model].stack

	var asset gltf.AssetId = g_models[id.model].asset
	var roots []i32 = gltf.AssetGetRootNodes(asset)
	var rootCount i32 = len(roots)

	var animations []Animation = g_models[id.model].animations
	var animationIndices []i32 = g_models[id.model].animationIndices
	var animationCounts []i32 = g_models[id.model].animationCounts

	var nodes []i32 = g_models[id.model].nodes
	var determinants []f32 = g_models[id.model].determinants
	var meshCacheKey []i32 = g_models[id.model].meshCacheKey
	var meshCacheVal []MeshId = g_models[id.model].meshCacheVal

	var meshes []MeshId = g_models[id.model].meshes

	var dataDir str = g_models[id.model].dataDir
	var primitives []Primitive = g_models[id.model].primitives

	var transparentMeshes []i32 = g_models[id.model].transparentMeshes
	var opaqueMeshes []i32 = g_models[id.model].opaqueMeshes

	var identity []f32 = g_models[id.model].identity

	var matrixStack []f32 = g_models[id.model].matrixStack
	matrixStack = resize(matrixStack, 0)
	matrixStack = mat.MatrixStackPush(matrixStack, identity)

	var transforms []f32 = g_models[id.model].transforms
	transforms = resize(transforms, 0)

	var min mat.v3 = mat.v3_max_val()
	var max mat.v3 = mat.v3_min_val()

	stack = resize(stack, rootCount)
	for i := 0; i < rootCount; i++ {
		stack[i] = roots[i]
	}

	for len(stack) > 0 {
		var stackLen i32 = len(stack)

		stackLen--
		var node i32 = stack[stackLen]
		stack = resize(stack, stackLen)

		if node < 0 {
			matrixStack = mat.MatrixStackPop(matrixStack, 0-node)
		} else {
			var stackPushed i32
			var nodeIndex i32 = len(nodes)
			nodes = append(nodes, node)

			var skeletonRoot i32 = g_models[id.model].skeletonRoot
			if skeletonRoot == -1 {
				var skin gltf.Skin = gltf.NodeGetSkin(asset, node)
				if skin.inverseBindMatrices != -1 {
					var accessor gltf.Accessor = gltf.AssetGetAccessor(asset, skin.inverseBindMatrices)
					g_models[id.model].inverseBind = accessor.dataF32
					g_models[id.model].jointMatrices = resize(g_models[id.model].jointMatrices, len(accessor.dataF32))
				}
				g_models[id.model].skeletonRoot = skin.skeleton
				g_models[id.model].joints = skin.joints
			}

			var animationCount i32 = gltf.NodeGetAnimationCount(asset, node)

			animationIndices = append(animationIndices, len(animations))
			animationCounts = append(animationCounts, animationCount)
			g_models[id.model].animationIndices = animationIndices
			for a := 0; a < animationCount; a++ {
				var animation Animation
				animation.index = -1
				animation.direction = 1.0

				var animationIndex i32 = -1
				var channel gltf.AnimationChannel
				channel.node = -1

				var sampler gltf.AnimationSampler
				animationIndex, channel, sampler = gltf.NodeGetAnimation(asset, node, a)

				animation.channel = channel
				animation.sampler = sampler
				animation.min, animation.max = gltf.AnimationGetLength(asset, animationIndex)
				animations = append(animations, animation)
				g_models[id.model].animated = true
			}

			var nodeMatrix []f32 = gltf.NodeGetMatrix(asset, node)
			var determinant f32 = mat.MatrixDeterminant(nodeMatrix)
			determinants = append(determinants, determinant)
			var cullFace i32 = gl.BACK
			if determinant < 0.0 {
				cullFace = gl.FRONT
			}
			if len(nodeMatrix) > 0 {
				matrixStack = mat.MatrixStackPush(matrixStack, nodeMatrix)
				stackPushed++
			}

			var last []f32 = mat.MatrixStackLast(matrixStack)
			for mi := 0; mi < 16; mi++ {
				transforms = append(transforms, last[mi])
			}

			var mesh i32 = gltf.NodeGetMesh(asset, node)
			var gltfPrimitives []gltf.Primitive = gltf.MeshGetPrimitives(asset, mesh)
			var gltfPrimitiveCount i32 = len(gltfPrimitives)

			for p := 0; p < gltfPrimitiveCount; p++ {

				var render MeshId = InvalidMesh()

				var gltfPrimitive gltf.Primitive = gltfPrimitives[p]
				var gltfMaterial gltf.Material = gltf.AssetGetMaterial(asset, gltfPrimitive.material)
				var metallicRoughness gltf.MetallicRoughness = gltfMaterial.pbrMetallicRoughness

				var indicesIndex i32 = gltfPrimitive.indices
				var meshCacheCount i32 = len(meshCacheKey)
				var pp i32
				for pp = 0; pp < meshCacheCount; pp++ {
					if meshCacheKey[pp] == indicesIndex {
						render = meshCacheVal[pp]
						pp = meshCacheCount
					}
				}

				if IsValidMesh(render) == false {
					render = meshInstance(asset, gltfPrimitive)
					MeshSetCulling(render, gl.CCW, cullFace)
					meshCacheKey = append(meshCacheKey, indicesIndex)
					meshCacheVal = append(meshCacheVal, render)
				}

				if IsValidMesh(render) == false {
					success = false
					return
				}

				meshes = append(meshes, render)
				var meshMin mat.v3 = g_meshes[render.mesh].min
				meshMin = mat.v3_transform_point(meshMin, last)

				var meshMax mat.v3 = g_meshes[render.mesh].max
				meshMax = mat.v3_transform_point(meshMax, last)

				max = mat.v3_max(meshMax, max)
				min = mat.v3_min(meshMin, min)

				var primitive Primitive

				primitive.mesh = render
				primitive.node = node
				primitive.nodeIndex = nodeIndex
				primitive.baseTexture = loadTexture(asset, dataDir, metallicRoughness.baseColorTexture.index)
				primitive.metalRoughTexture = loadTexture(asset, dataDir, metallicRoughness.metallicRoughnessTexture.index)
				primitive.emissiveTexture = loadTexture(asset, dataDir, gltfMaterial.emissiveTexture.index)
				primitive.normalTexture = loadTexture(asset, dataDir, gltfMaterial.normalTexture.index)
				primitive.occlusionTexture = loadTexture(asset, dataDir, gltfMaterial.occlusionTexture.index)
				primitive.gltfMaterial = gltfMaterial
				primitive.gltfPrimitive = gltfPrimitive
				if MeshUseWeight(render) &&  MeshUseJoint(render) {
					primitive.useSkin = 1
				}

				var effect EffectId = effectInstance(&primitive)
				if EffectIsValid(effect) == false {
					printf("effectInstance failed\n")
					success = false
					return
				}
				primitive.effect = effect

				var primitiveIndex i32 = len(primitives)
				primitives = append(primitives, primitive)

				var alphaMode i32 = gltfMaterial.alphaMode
				if alphaMode == gltf.ALPHA_BLEND {
					transparentMeshes = append(transparentMeshes, primitiveIndex)
				} else if alphaMode == gltf.ALPHA_OPAQUE {
					opaqueMeshes = append(opaqueMeshes, primitiveIndex)
				}

		   }

			var children []i32 = gltf.NodeGetChildren(asset, node)
			var childCount i32 = len(children)
			if stackPushed > 0 {
				stack = append(stack, 0-stackPushed)
			}
			if childCount > 0 {
				for i := 0; i < childCount; i++ {
					stack = append(stack, children[i])
				}
			}
		}
	}

	stack = resize(stack, 0)
	g_models[id.model].stack = stack
	g_models[id.model].nodes = nodes
	g_models[id.model].determinants = determinants
	g_models[id.model].meshes = meshes
	g_models[id.model].primitives = primitives
	g_models[id.model].opaqueMeshes = opaqueMeshes
	g_models[id.model].transparentMeshes = transparentMeshes
	g_models[id.model].meshCacheKey = meshCacheKey
	g_models[id.model].meshCacheVal = meshCacheVal
	g_models[id.model].animations = animations
	g_models[id.model].animationIndices = animationIndices
	g_models[id.model].animationCounts = animationCounts
	g_models[id.model].matrixStack = resize(matrixStack, 0)
	g_models[id.model].transforms = transforms
	g_models[id.model].max = max
	g_models[id.model].min = min

	success = true
}

func animationUpdate(id ModelId, deltaTime f32, loop bool) {
}

func debugNode(stackCount i32, asset gltf.AssetId, node i32) {
	for kk := 0; kk < stackCount; kk++ {
		printf("--")
	}

	printf("%s :\n", gltf.NodeGetName(asset, node))
}

func modelUpdate(id ModelId, deltaTime f32, loop bool) {
	panicIfNot(ModelIsValid(id), "invalid model")

	var animations []Animation = g_models[id.model].animations
	var animationIndices []i32 = g_models[id.model].animationIndices
	var animationCounts []i32 = g_models[id.model].animationCounts

	var transforms []f32 = g_models[id.model].transforms
	transforms = resize(transforms, 0)

	var nodeIndex i32

	var tmp2 []f32 = g_models[id.model].tmp2
	var identity []f32 = g_models[id.model].identity

	var matrixStack []f32 = g_models[id.model].matrixStack
	matrixStack = resize(matrixStack, 0)
	matrixStack = mat.MatrixStackPush(matrixStack, identity)

	var stack []i32 = g_models[id.model].stack

	var asset gltf.AssetId = g_models[id.model].asset
	var roots []i32 = gltf.AssetGetRootNodes(asset)
	var rootCount i32 = len(roots)
	stack = resize(stack, rootCount)
	for i := 0; i < rootCount; i++ {
		stack[i] = roots[i]
	}

	var stackCount i32
	var skin bool = g_models[id.model].skeletonRoot >= 0
	for len(stack) > 0 {
		var stackLen i32 = len(stack)

		stackLen--
		var node i32 = stack[stackLen]

		stack = resize(stack, stackLen)
		var animMatrix []f32 = g_models[id.model].animation
		animMatrix = mat.MatrixIdentity(animMatrix)
		if node < 0 {
			stackCount = stackCount - 1
			matrixStack = mat.MatrixStackPop(matrixStack, 0-node)
		} else {
			stackCount = stackCount + 1
			var stackPushed i32 = 0
			tmp2 = mat.MatrixIdentity(tmp2)
			var animationIndex i32 = animationIndices[nodeIndex]
			var animationCount i32 = animationCounts[nodeIndex]

			var useTX i32
			var useRX i32
			var useSX i32
			var animTranslation v3 = mat.v3_(0.0, 0.0, 0.0)
			var animRotation v4 = mat.v4_(0.0, 0.0, 0.0, 1.0)
			var animScale v3 = mat.v3_(1.0, 1.0, 1.0)

			for a := 0; a < animationCount; a++ {
				var anim bool

				var animation Animation = animations[animationIndex + a]

				if animation.channel.node >= 0 {
					animation.time = animation.time + animation.direction * deltaTime
					if animation.time < animation.min {
						if loop == true {
							animation.time = animation.max
						} else {
							animation.time = animation.min
							animation.direction = 1.0
						}
					}
					if animation.time > animation.max {
						if loop == true {
							animation.time = 0.0//animation.min
						} else {
							animation.time = animation.max
							animation.direction = -1.0
						}
					}

					var index i32 = -1
					var inputAccessor gltf.Accessor = gltf.AssetGetAccessor(asset, animation.sampler.inputA)
					var inputs []f32 = inputAccessor.dataF32
					var inputCount i32 = len(inputs)
					for t := 0; t < inputCount; t++ {
						if animation.time <= inputs[t] {
							index = t
							t = inputCount // ISSUE : break
						}
					}

					if index >= inputCount {
						index = inputCount - 1
					}
					if index < 0 {
						index = 0
					}

					var prev i32 = index - 1
					if prev < 0 {
						prev = 0
					}

					var delta f32 = animation.time - inputs[prev]
					var step f32 = inputs[index] - inputs[prev]
					var st f32 = 1.0;
					if step > 0.0 {
						st = delta / step
					}
					var t f32 = st
					if t < 0.0 {
						t = 0.0
					} else if t > 1.0 {
						t = 1.0
					}

					var outputAccessor gltf.Accessor = gltf.AssetGetAccessor(asset, animation.sampler.outputA)
					var outputs []f32 = outputAccessor.dataF32
					var path i32 = animation.channel.path
					if path == gltf.ANIMATION_PATH_TRANSLATION {
						panicIf(outputAccessor.attributeTypeEnum != gltf.TYPE_VEC3, "invalid attribute type")
						panicIf(outputAccessor.componentType != gl.FLOAT, "unhandled component type")
						var x0 f32 = outputs[prev * 3 + 0]
						var y0 f32 = outputs[prev * 3 + 1]
						var z0 f32 = outputs[prev * 3 + 2]

						var x1 f32 = outputs[index * 3 + 0]
						var y1 f32 = outputs[index * 3 + 1]
						var z1 f32 = outputs[index * 3 + 2]

						var x f32 = x0 + (x1 - x0) * t
						var y f32 = y0 + (y1 - y0) * t
						var z f32 = z0 + (z1 - z0) * t

						anim = true
						animTranslation = mat.v3_(x, y, z)
						useTX = 1
					} else if path == gltf.ANIMATION_PATH_ROTATION {
						panicIf(outputAccessor.attributeTypeEnum != gltf.TYPE_VEC4, "invalid attribute type")
						panicIf(outputAccessor.componentType != gl.FLOAT, "unhandled component type")
						var x0 f32 = outputs[prev * 4 + 0]
						var y0 f32 = outputs[prev * 4 + 1]
						var z0 f32 = outputs[prev * 4 + 2]
						var w0 f32 = outputs[prev * 4 + 3]

						var x1 f32 = outputs[index * 4 + 0]
						var y1 f32 = outputs[index * 4 + 1]
						var z1 f32 = outputs[index * 4 + 2]
						var w1 f32 = outputs[index * 4 + 3]

						var x f32 = x0 + (x1 - x0) * t
						var y f32 = y0 + (y1 - y0) * t
						var z f32 = z0 + (z1 - z0) * t
						var w f32 = w0 + (w1 - w0) * t

						/*var q mat.v4 = mat.QuaternionSlerp(
								mat.v4_normalize(mat.v4_(x0, y0, z0, w0)),
								mat.v4_normalize(mat.v4_(x1, y1, z1, w1)), t)*/
						var q mat.v4 = mat.v4_normalize(mat.v4_(x, y, z, w))

						animRotation = q
						anim = true
						useRX = 1
					} else if path == gltf.ANIMATION_PATH_SCALE {
						panicIf(outputAccessor.attributeTypeEnum != gltf.TYPE_VEC3, "invalid attribute type")
						panicIf(outputAccessor.componentType != gl.FLOAT, "unhandled component type")
						var x0 f32 = outputs[prev * 3 + 0]
						var y0 f32 = outputs[prev * 3 + 1]
						var z0 f32 = outputs[prev * 3 + 2]

						var x1 f32 = outputs[index * 3 + 0]
						var y1 f32 = outputs[index * 3 + 1]
						var z1 f32 = outputs[index * 3 + 2]

						var x f32 = x0 + (x1 - x0) * t
						var y f32 = y0 + (y1 - y0) * t
						var z f32 = z0 + (z1 - z0) * t

						animScale = mat.v3_(x, y, z)
						useSX = 1
						anim = true
					} else if path == gltf.ANIMATION_PATH_WEIGHTS {
					} else {
						panicIf(true, "invalid animation path")
					}

					animations[animationIndex + a] = animation
				}
			}
			nodeIndex++

			var nodeMatrix []f32 = gltf.NodeGetMatrix(asset, node)

			if anim {
				if useTX == 0 {
					animTranslation = gltf.NodeGetTranslation(asset, node)
				}
				if useRX == 0 {
					animRotation = gltf.NodeGetRotation(asset, node)
				}
				if useSX == 0 {
					animScale = gltf.NodeGetScale(asset, node)
				}
				tmp2 = mat.MatrixCreate2(tmp2, animScale.x, animScale.y, animScale.z,
						animRotation.x, animRotation.y, animRotation.z, animRotation.w,
						animTranslation.x, animTranslation.y, animTranslation.z)
   				matrixStack = mat.MatrixStackPush(matrixStack, tmp2)
				stackPushed++
			}

			if anim == false || skin == false {
				if len(nodeMatrix) > 0 {
					matrixStack = mat.MatrixStackPush(matrixStack, nodeMatrix)
					stackPushed++
				}
			}

			var useNode bool = true

			//debugNode(stackCount, asset, node)

			var joints []i32 = g_models[id.model].joints
			var last []f32 = mat.MatrixStackLast(matrixStack)
			for j := 0; j < len(joints); j++ {
				if joints[j] == node {
					var inverseBind []f32 = g_models[id.model].inverseBind
					var tmp []f32 = g_models[id.model].tmp
					for mi := 0; mi < 16; mi++ {
						tmp[mi] = inverseBind[j * 16 + mi]
					}

					tmp = mat.MatrixMultiply(tmp, tmp, last)

					var jointMatrices []f32 = g_models[id.model].jointMatrices
					for mi := 0; mi < 16; mi++ {
						jointMatrices[j * 16 + mi] = tmp[mi]
					}
					j = len(joints)
					last = tmp
				}
			}

			for mi := 0; mi < 16; mi++ {
				transforms = append(transforms, last[mi])
			}

			var children []i32 = gltf.NodeGetChildren(asset, node)
			var childCount i32 = len(children)
			if stackPushed > 0 {
				stack = append(stack, 0-stackPushed)
			}
			if childCount > 0 {
				for i := 0; i < childCount; i++ {
					stack = append(stack, children[i])
				}
			}
		}
	}

	g_models[id.model].stack = resize(stack, 0)
	g_models[id.model].matrixStack = resize(matrixStack, 0)
	g_models[id.model].transforms = transforms
}

func modelRender(id ModelId, alpha bool) {
	panicIfNot(ModelIsValid(id), "invalid model")

	var tmp []f32 = g_models[id.model].tmp
	var world []f32 = g_models[id.model].world
	var transforms []f32 = g_models[id.model].transforms
	var primitives []Primitive = g_models[id.model].primitives
	var renderables []i32
	var skin bool = g_models[id.model].skeletonRoot >= 0

	var environmentSpecular TextureId = g_models[id.model].environmentSpecular
	var environmentDiffuse TextureId = g_models[id.model].environmentDiffuse
	var brdf TextureId = g_models[id.model].brdf

	var view []f32 = g_models[id.model].view
	var projection []f32 = g_models[id.model].projection
	var jointMatrices []f32 = g_models[id.model].jointMatrices
	var color []f32 = color = g_models[id.model].color
	var cameraPosition []f32 = g_models[id.model].cameraPosition

	if alpha == true {
		renderables = g_models[id.model].transparentMeshes
	} else {
		renderables = g_models[id.model].opaqueMeshes
	}
	var renderableCount i32 = len(renderables)

	for p := 0; p < renderableCount; p++ {
		var renderable i32 = renderables[p]
		var primitive Primitive = primitives[renderable]//renderables[p]]
		var effect EffectId = effectInstance(&primitive)

		EffectTryAssignTexture(effect, SAMPLER_COLOR_0, primitive.baseTexture, g_linearWrap) // TODO : use gltf sampler
		EffectTryAssignTexture(effect, SAMPLER_NORMAL, primitive.normalTexture, g_linearWrap) // TODO : use gltf sampler
		EffectTryAssignTexture(effect, SAMPLER_METAL_ROUGH, primitive.metalRoughTexture, g_linearWrap) // TODO : use gltf sampler
		EffectTryAssignTexture(effect, SAMPLER_ENV_SPECULAR, environmentSpecular, g_linearWrap) // TODO : use gltf sampler
		EffectTryAssignTexture(effect, SAMPLER_ENV_DIFFUSE, environmentDiffuse, g_linearWrap) // TODO : use gltf sampler
		EffectTryAssignTexture(effect, SAMPLER_BRDF, brdf, g_linear0Wrap) // TODO : use gltf sampler
		EffectTryAssignTexture(effect, SAMPLER_EMISSIVE, primitive.emissiveTexture, g_linearWrap) // TODO : use gltf sampler
		EffectTryAssignTexture(effect, SAMPLER_OCCLUSION, primitive.occlusionTexture, g_linearWrap) // TODO : use gltf sampler

		var nodeIndex i32 = primitive.nodeIndex
		if skin == true {
			for ii := 0; ii < 16; ii++ {
				tmp[ii] = world[ii]
			}
		}

		if skin == false {
			var mi i32 // ISSUE : can't use short declaration here
			for mi = 0; mi < 16; mi++ {
				tmp[mi] = transforms[nodeIndex * 16 + mi]
			}
			tmp = mat.MatrixMultiply(tmp, tmp, world)
		}

		EffectAssignMatrix4(effect, UNIFORM_WORLD, tmp, false)
		EffectAssignMatrix4(effect, UNIFORM_VIEW, view, false)
		EffectAssignMatrix4(effect, UNIFORM_PROJECTION, projection, false)

		tmp = mat.MatrixInverse(tmp, tmp)
		EffectAssignMatrix4(effect, UNIFORM_WORLD_INVERSE, tmp, false)
		if primitive.useSkin == 1 {
	  		EffectAssignMatrix4(effect, UNIFORM_SKELETON, jointMatrices, false)
		}

		var metallicRoughness gltf.MetallicRoughness = primitive.gltfMaterial.pbrMetallicRoughness
		if EffectIsValidUniformLocation(effect, UNIFORM_COLOR) {
	  		var baseColorFactor [4]f32
	  		baseColorFactor = metallicRoughness.baseColorFactor
	  		color[0] = baseColorFactor[0]
	  		color[1] = baseColorFactor[1]
	  		color[2] = baseColorFactor[2]
	  		color[3] = baseColorFactor[3]
	  		EffectAssignVector4(effect, UNIFORM_COLOR, color)
		}

		if EffectIsValidUniformLocation(effect, UNIFORM_METAL_ROUGH) {
	  		color[0] = 0.0
	  		color[1] = metallicRoughness.roughnessFactor
	  		color[2] = metallicRoughness.metallicFactor
	  		color[3] = 0.0
	  		EffectAssignVector4(effect, UNIFORM_METAL_ROUGH, color)
		}

		if EffectIsValidUniformLocation(effect, UNIFORM_EMISSIVE) {
	  		var emissiveFactor [4]f32
	  		color[0] = emissiveFactor[0]
	  		color[1] = emissiveFactor[1]
	  		color[2] = emissiveFactor[2]
	  		color[3] = emissiveFactor[3]
	  		EffectAssignVector4(effect, UNIFORM_EMISSIVE, color)
		}

		EffectAssignVector4(effect, UNIFORM_CAMERA_POSITION, cameraPosition)
		EffectAssignVector4(effect, UNIFORM_DEBUG_0, DEBUG_0)

		MeshRender(primitive.mesh)
	}
}
