package gfx

import "gltf"

// Globals ...
var g_models []Model
var g_animations []Animation // ISSUE : can't be named g_animations as it clashes at runtime with src/gui/animation.cx::g_animations

// AnimationId ...
type AnimationId struct {
	animation i32
}

// AnimationSource ...
type AnimationSource struct {
	offset i32
	count i32
	time f32
	direction f32
}

// Animation ...
type Animation struct {
	channels []gltf.AnimationChannel
	samplers []gltf.AnimationSampler
	sources []AnimationSource
	indices []i32
	min f32
	max f32
}

type Skeleton struct {
	root i32
}

type Primitive struct {
	mesh MeshId
	node i32
	nodeIndex i32

	effect EffectId

	useSkin i32
	baseTexture TextureId
	metalRoughTexture TextureId
	emissiveTexture TextureId
	normalTexture TextureId
	occlusionTexture TextureId

	gltfPrimitive gltf.Primitive
	gltfMaterial gltf.Material
}

// ModelId ...
type ModelId struct {
	model i32
}

// Model ...
type Model struct {
	asset gltf.AssetId

	dataDir str
	filename str

   	animated bool
	skinned bool

	min mat.v3
	max mat.v3

	nodes[]i32
	nodesMap[]i32
	determinants []f32
	transforms []f32
	matrixStack []f32

	meshes []MeshId
	meshCacheKey []i32
	meshCacheVal []MeshId
	primitives []Primitive
	opaqueMeshes []i32
	transparentMeshes []i32

	skeleton Skeleton

	animations []i32

	environmentSpecular TextureId // TODO : remove
	environmentDiffuse TextureId // TODO : remove
	brdf TextureId // TODO : remove
	cameraPosition []f32 // TODO : remove

	inverseBind []f32 // TODO : skeleton struct
	joints []i32 // TODO : skeleton struct
	jointMatrices []f32 // TODO : runtime struct

	stack []i32 // TODO : remove
	color []f32 // TODO : remove
	identity []f32 // TODO : remove
	world []f32 // TODO : remove
	view []f32 // TODO : remove
	projection []f32 // TODO : remove
	tmp []f32 // TODO : remove
	tmp2 []f32 // TODO : remove
}

// ModelIsValid ...
func ModelIsValid(id ModelId) (out bool) {
	out = id.model >= 0 && id.model < len(g_models)
}

// ModelInvalid ...
func ModelInvalid() (out ModelId) {
	out.model = -1
}

// ModelCreateFromFile ...
func ModelCreateFromFile(dataDir str, filename str) (out ModelId){ // TODO : only load animations
	out.model = len(g_models)

	var model Model
	model.color = resize(model.color, 4)
	model.color[0] = 1.0
	model.color[1] = 0.0
	model.color[2] = 1.0
	model.color[3] = 1.0
	model.dataDir = dataDir
	model.filename = filename
	model.asset = gltf.AssetCreate(dataDir, filename)
	if gltf.AssetIsValid(model.asset) == false {
		printf("gltf.AssetCreate failed\n")
		out = ModelInvalid()
		return
	}

	var tmp []f32 = mat.MatrixAlloc()
	model.tmp = tmp

	var tmp2 []f32 = mat.MatrixAlloc()
	model.tmp2 = tmp2

	var world []f32 = mat.MatrixAlloc()
	model.world = world

	var view []f32 = mat.MatrixAlloc()
	model.view = view

	var projection []f32 = mat.MatrixAlloc()
	model.projection = projection

	var identity []f32 = mat.MatrixAlloc()
	model.identity = mat.MatrixIdentity(identity)

	model.skeleton.root = -1

	//gltf.AssetPrint(model.asset)

	g_models = append(g_models, model)

	if modelInstance(out) == false {
		printf("modelInstance failed\n")
		out = ModelInvalid()
		return
	}

	modelUpdate(out, ModelInvalid(), 0, 0.0, false)
}

// ModelGetMin ...
func ModelGetMin(id ModelId) (out mat.v3) {
	panicIfNot(ModelIsValid(id), "invalid model")
	out = g_models[id.model].min
}

// ModelGetMax ...
func ModelGetMax(id ModelId) (out mat.v3) {
	panicIfNot(ModelIsValid(id), "invalid model")
	out = g_models[id.model].max
}

// ModelGetAnimation ...
func ModelGetAnimation(id ModelId, animationIndex i32) (out i32) {
	out = -1
	panicIfNot(ModelIsValid(id), "invalid model")

	var modelIndex i32 = id.model

	var animationCount i32 = len(g_models[modelIndex].animations)
	panicIfNot(animationIndex >= 0 && animationIndex < animationCount, "invalid animation")

	if animationIndex >= 0 && animationIndex < animationCount {
		out = g_models[modelIndex].animations[animationIndex]
	}
}

type channelInfo struct {
	count i32
	dataType i32
	dataLen i32
	dataF32 []f32
	dataUI8 []ui8
	dataUI16 []ui16
	dataUI32 []ui32
}

func effectInstance(primitive *Primitive) (out EffectId) {
	var mesh MeshId = primitive.mesh

	var useColorVtx bool = MeshUseColor(mesh)
	var useColorMap bool = IsValidTexture(primitive.baseTexture)
	var useColorUni bool = useColorMap == false

	var usePbrMap bool = IsValidTexture(primitive.metalRoughTexture)
	var usePbrUni bool = usePbrMap == false

	var useEmissiveMap bool = IsValidTexture(primitive.emissiveTexture)
	var useEmissiveUni bool = useEmissiveMap == false

	var useNormalMap bool = IsValidTexture(primitive.normalTexture)
	var useNormalVtx bool = MeshUseNormal(mesh)
	var useTangentVtx bool = MeshUseTangent(mesh)

	var useOcclusionTexture bool = IsValidTexture(primitive.occlusionTexture)

	var useWeights bool = MeshUseWeight(mesh)
	var useJoints bool = MeshUseJoint(mesh)
	var useSkin bool = useWeights && useJoints

	TemplateSetKey(g_tfxPbr, USE_COLOR_UNI, useColorUni)
	TemplateSetKey(g_tfxPbr, USE_COLOR_VTX, useColorVtx)
	TemplateSetKey(g_tfxPbr, USE_COLOR_MAP, useColorMap)

	TemplateSetKey(g_tfxPbr, USE_PBR_UNI, usePbrUni)
	TemplateSetKey(g_tfxPbr, USE_PBR_MAP, usePbrMap)

	TemplateSetKey(g_tfxPbr, USE_EMISSIVE_UNI, useEmissiveUni)
	TemplateSetKey(g_tfxPbr, USE_EMISSIVE_MAP, useEmissiveMap)

	TemplateSetKey(g_tfxPbr, USE_NORMAL_VTX, useNormalVtx)
	TemplateSetKey(g_tfxPbr, USE_NORMAL_MAP, useNormalMap)
	TemplateSetKey(g_tfxPbr, USE_TANGENT_VTX, useTangentVtx)

	TemplateSetKey(g_tfxPbr, USE_OCCLUSION_MAP, useOcclusionTexture)

	TemplateSetKey(g_tfxPbr, USE_SKIN, useSkin)

	TemplateSetKey(g_tfxPbr, USE_DEBUG_A, true)

	out = TemplateInstance(g_tfxPbr)
}

func meshInstance(id gltf.AssetId, primitive gltf.Primitive) (out MeshId) {
	var mode i32
	//printf("instancing : mode %d, indices %d, material %d\n", primitive.mode, primitive.indices, primitive.material)
	if primitive.mode == gltf.PRIMITIVE_LINES {
		mode = gl.LINES
	} else if primitive.mode == gltf.PRIMITIVE_TRIANGLES {
		mode = gl.TRIANGLES
	} else {
		printf("primitive type not implemented\n")
		out = InvalidMesh()
		return
	}

	var min mat.v3
	var max mat.v3

	var usePosition bool
	var useNormal bool
	var useColor bool
	var useTexcoord bool
	var useTangent bool
	var useWeight bool
	var useJoint bool

	// attributes
	var channels []channelInfo
	var attributes []VertexAttribute
	var vertexCount i32 = 0
	var attributeCount i32 = len(primitive.attributes)
	var byteStride i32 = 0
	var componentStride i32 = 0
	for a := 0; a < attributeCount; a++ {
		var accessor gltf.Accessor = gltf.AssetGetAccessor(id, primitive.attributes[a].accessor)
		if a > 0 && accessor.count != vertexCount {
			printf("wrong number of vectices\n")
			out = InvalidMesh()
			return
		}

		vertexCount = accessor.count

   		var channel channelInfo
		var attribute VertexAttribute

		if accessor.componentType == gl.FLOAT { // TODO : how to pass []struct to BufferData ?
			channel.dataF32 = accessor.dataF32
			channel.dataLen = len(channel.dataF32)
   			channel.dataType = gl.FLOAT
			attribute.componentType = gl.FLOAT
			attribute.componentByteSize = g_sizeofF32
		} else if accessor.componentType == gl.UNSIGNED_SHORT {
			channel.dataUI16 = accessor.dataUI16
			channel.dataLen = len(channel.dataUI16)
   			channel.dataType = gl.UNSIGNED_SHORT
			attribute.componentType = gl.UNSIGNED_SHORT
			attribute.componentByteSize = g_sizeofUI16
		} else if accessor.componentType == gl.UNSIGNED_INT {
			channel.dataUI32 = accessor.dataUI32
			channel.dataLen = len(channel.dataUI32)
			channel.dataType = gl.UNSIGNED_INT
			attribute.componentType = gl.UNSIGNED_INT
			attribute.componentByteSize = g_sizeofUI32
		} else {
			printf("buffer type not implemented %d\n", accessor.componentType)
			out = InvalidMesh()
			return
		}

		attribute.componentCount = accessor.componentCount
		attribute.componentOffset = componentStride
		attribute.byteOffset = byteStride

		var attributeType i32 = primitive.attributes[a].attributeType
		var binding i32 = -1
		if attributeType == gltf.ATTRIBUTE_POSITION {
			binding = ATTRIBUTE_POSITION
			min.x = accessor.min[0]
			min.y = accessor.min[1]
			min.z = accessor.min[2]
			max.x = accessor.max[0]
			max.y = accessor.max[1]
			max.z = accessor.max[2]
		} else if attributeType == gltf.ATTRIBUTE_NORMAL {
			binding = ATTRIBUTE_NORMAL
			useNormal = true
		} else if attributeType == gltf.ATTRIBUTE_COLOR {
			binding = ATTRIBUTE_COLOR
			useColor = true
		} else if attributeType == gltf.ATTRIBUTE_TEXCOORD {
			binding = ATTRIBUTE_TEXCOORD
			useTexcoord = true
		} else if attributeType == gltf.ATTRIBUTE_TANGENT {
			binding = ATTRIBUTE_TANGENT
			useTangent = true
		} else if attributeType == gltf.ATTRIBUTE_WEIGHT {
			binding = ATTRIBUTE_WEIGHT
			useWeight = true
		} else if attributeType == gltf.ATTRIBUTE_JOINT {
			binding = ATTRIBUTE_JOINT
			useJoint = true
		}

		attribute.binding = binding
		channel.count = attribute.componentCount

		attributes = append(attributes, attribute)
		channels = append(channels, channel)

		byteStride = byteStride + attribute.componentCount * attribute.componentByteSize
		componentStride = componentStride + attribute.componentCount
	}

	var vertexLen i32 = componentStride * vertexCount
	if vertexLen <= 0 {
		printf("invalid vertex buffer\n")
		out = InvalidMesh()
		return
	}

	// vertices // TODO : generate buffers from go data ?
	var vertices []ui8 // TODO : test perf with loop reordering + resize(vertices, vertexLen)
	for v := 0; v < vertexCount; v++ {
		for c := 0; c < attributeCount; c++ {
			var dataType i32 = channels[c].dataType
			var dataLen i32 = channels[c].dataLen
			var count i32 = channels[c].count
			var offset i32 = v * count
			if dataType == gl.FLOAT {
				var data []f32 = channels[c].dataF32
				for i := 0; i < count; i++ {
					vertices = gl.AppendF32(vertices, data[offset + i])
				}
			} else if dataType == gl.UNSIGNED_SHORT {
				var data []ui16 = channels[c].dataUI16
				for i := 0; i < count; i++ {
					vertices = gl.AppendUI16(vertices, data[offset + i])
				}
			} else if dataType == gl.UNSIGNED_INT {
				var data []ui32 = channels[c].dataUI32
				for i := 0; i < count; i++ {
					vertices = gl.AppendUI32(vertices, data[offset + i])
				}
			} else {
				panicIf(true, "unhandled dataType")
			}
		}
	}

	// indices
	var indices []ui8
	var indicesAccessor gltf.Accessor = gltf.AssetGetAccessor(id, primitive.indices)
	var indicesType i32 = indicesAccessor.componentType
	if indicesAccessor.componentCount != 1 ||
	   (indicesAccessor.componentType != gl.UNSIGNED_SHORT && indicesAccessor.componentType != gl.UNSIGNED_INT) ||
	   indicesAccessor.attributeTypeEnum != gltf.TYPE_SCALAR {
		printf("invalid index buffer format : componentCount %d, componentType %d, attributeType %d\n",
			indicesAccessor.componentCount, indicesAccessor.componentType, indicesAccessor.attributeTypeEnum)
		out = InvalidMesh()
		return
	}

	var indexByteCount i32 = 0
	if indicesType == gl.UNSIGNED_SHORT {
		var data []ui16 = indicesAccessor.dataUI16
		var count i32 = len(data)
		indexByteCount = 2
		for i := 0; i < count; i++ {
			indices = gl.AppendUI16(indices, data[i])
		}
	} else if indicesType == gl.UNSIGNED_INT {
		var data []ui32 = indicesAccessor.dataUI32
		var count i32 = len(data)
		indexByteCount = 4
		for i := 0; i < count; i++ {
			indices = gl.AppendUI32(indices, data[i])
		}
	} else {
		printf("invalid index buffer type\n")
		out = InvalidMesh()
		return
	}

	if len(attributes) > 0 && len(indices) > 0 && len(vertices) > 0 {
		out = MeshCreate(mode, indicesType, len(indices) / indexByteCount, attributes, len(vertices) / byteStride) // TODO : use real index/vertex count instead of bytecount
		MeshBegin(out) // TODO : remove MeshBegin/MeshEnd, data should be uploaded with BufferData in MeshInstance.
		g_meshes[out.mesh].vertices = vertices
		g_meshes[out.mesh].indices = indices
		g_meshes[out.mesh].usePosition = usePosition
		g_meshes[out.mesh].useNormal = useNormal
		g_meshes[out.mesh].useColor = useColor
		g_meshes[out.mesh].useTexcoord = useTexcoord
		g_meshes[out.mesh].useTangent = useTangent
		g_meshes[out.mesh].useWeight = useWeight
		g_meshes[out.mesh].useJoint = useJoint
		g_meshes[out.mesh].min = min
		g_meshes[out.mesh].max = max
		MeshEnd(out)
	}
}

// ModelSetCameraPosition ...
func ModelSetCameraPosition(id ModelId, position mat.v3) {
	panicIfNot(ModelIsValid(id), "invalid model")
	var cameraPosition []f32 = g_models[id.model].cameraPosition
	cameraPosition = resize(cameraPosition, 4)
	cameraPosition[0] = position.x
	cameraPosition[1] = position.y
	cameraPosition[2] = position.z
	cameraPosition[3] = 1.0
	g_models[id.model].cameraPosition = cameraPosition
}


// ModelSetEnvironmentSpecular ...
func ModelSetEnvironmentSpecular(id ModelId, environment TextureId) { 
	panicIfNot(ModelIsValid(id), "invalid model")
	g_models[id.model].environmentSpecular = environment
}

// ModelSetEnvironmentDiffuse...
func ModelSetEnvironmentDiffuse(id ModelId, environment TextureId) { 
	panicIfNot(ModelIsValid(id), "invalid model")
	g_models[id.model].environmentDiffuse = environment
}

// ModelSetBRDF ...
func ModelSetBRDF(id ModelId, brdf TextureId) {
	panicIfNot(ModelIsValid(id), "invalid model")
	g_models[id.model].brdf = brdf
}

// ModelSetWorld ...
func ModelSetWorld(id ModelId, world []f32) {
	panicIfNot(ModelIsValid(id), "invalid model")
	var i i32 = copy(g_models[id.model].world, world)
}

// ModelSetView ...
func ModelSetView(id ModelId, view []f32) {
	panicIfNot(ModelIsValid(id), "invalid model")
	var i i32 = copy(g_models[id.model].view, view)
}

// ModelSetProjection ...
func ModelSetProjection(id ModelId, projection []f32) {
	panicIfNot(ModelIsValid(id), "invalid model")
	var i i32 = copy(g_models[id.model].projection, projection)
}

func loadTexture(asset AssetId, dataDir str, index i32) (out TextureId) {
	out = InvalidTexture()
	//if gltf.AssetIsValidTexture(asset, index) {
		var texture gltf.Texture = gltf.AssetGetTexture(asset, index)
		var image gltf.Image = gltf.AssetGetImage(asset, texture.source)
		if image.uri != "" {
			out = TextureCreate(sprintf("%s%s", dataDir, image.uri), FORMAT_R8_G8_B8_A8, 0, 0, -1, false)
		}
	//}
}

// ModelUpdate ...
func ModelUpdate(id ModelId, animId ModelId, animationIndex i32, deltaTime f32, loop bool) { // TODO : bound check
	panicIfNot(ModelIsValid(id), "invalid model")
	if g_models[id.model].animated || g_models[id.model].skinned {
		modelUpdate(id, animId, animationIndex, deltaTime, loop)
	}
}

// ModelRender ...
func ModelRender(id ModelId) {
	DisableBlending()
	DepthState(true, LESS, true)
	modelRender(id, false)

	EnableBlending(SRC_ALPHA, ONE_MINUS_SRC_ALPHA)
	DepthState(true, LESS, true)
	modelRender(id, true)
}

func modelInstance(id ModelId) (success bool) {
	panicIfNot(ModelIsValid(id), "invalid model")
	var modelIndex i32 = id.model

	var stack []i32 = g_models[modelIndex].stack

	var asset gltf.AssetId = g_models[modelIndex].asset
	var roots []i32 = gltf.AssetGetRootNodes(asset)
	var rootCount i32 = len(roots)

	var animations []i32 = g_models[modelIndex].animations

	var nodes []i32 = g_models[modelIndex].nodes
	var nodesMap []i32 = g_models[modelIndex].nodesMap

	var determinants []f32 = g_models[modelIndex].determinants
	var meshCacheKey []i32 = g_models[modelIndex].meshCacheKey
	var meshCacheVal []MeshId = g_models[modelIndex].meshCacheVal

	var meshes []MeshId = g_models[modelIndex].meshes

	var dataDir str = g_models[modelIndex].dataDir
	var primitives []Primitive = g_models[modelIndex].primitives

	var transparentMeshes []i32 = g_models[modelIndex].transparentMeshes
	var opaqueMeshes []i32 = g_models[modelIndex].opaqueMeshes

	var identity []f32 = g_models[modelIndex].identity

	var matrixStack []f32 = g_models[modelIndex].matrixStack
	matrixStack = resize(matrixStack, 0)
	matrixStack = mat.MatrixStackPush(matrixStack, identity)

	var transforms []f32 = g_models[modelIndex].transforms
	transforms = resize(transforms, 0)

	var min mat.v3 = mat.v3_max_val()
	var max mat.v3 = mat.v3_min_val()

	stack = resize(stack, rootCount)
	for i := 0; i < rootCount; i++ {
		stack[i] = roots[i]
	}

	var gltfAnimations []gltf.Animation = gltf.AssetGetAnimations(asset)
	var animationCount i32 = len(gltfAnimations)
	g_models[modelIndex].animated = animationCount > 0 // TODO : multiple models per scene
	for i := 0; i < animationCount; i++ {

		var channels []gltf.AnimationChannel = gltfAnimations[i].channels

		var animation Animation
		animation.channels = channels
		animation.min, animation.max = gltf.AnimationGetLength(asset, i)

		var offsetCount i32
		var channelCount i32 = len(channels)
		for c := 0; c < channelCount; c++ {
			var channel gltf.AnimationChannel = channels[c]
			var channelNode i32 = channel.node
			if channelNode >= offsetCount {
				offsetCount = channelNode + 1
			}
		}

		var samplers []gltf.AnimationSampler = gltfAnimations[i].samplers
		animation.samplers = samplers

		var sources []AnimationSource
		//sources = resize(sources, offsetCount) // ISSUE : can't use resize
		for o := 0; o < offsetCount; o++ {
			var source AnimationSource
			source.offset = -1
			source.direction = 1.0
			sources = append(sources, source)
		}
		for c := 0; c < channelCount; c++ {
			var channel gltf.AnimationChannel = channels[c]
			var channelNode i32 = channel.node
			var nodeChannelCount i32 = sources[channelNode].count
			sources[channelNode].count = nodeChannelCount + 1
		}
		var offset i32
		for o := 0; o < offsetCount; o++ {
			sources[o].offset = offset
			offset = offset + sources[o].count
		}

		panicIf(offset != channelCount, "invalid animation")

		var indices []i32
		//indices = resize(indices, channelCount) // ISSUE : can't use resize
		for c := 0; c < channelCount; c++ {
			indices = append(indices, -1)//indices[c] = -1
		}
		for c := 0; c < channelCount; c++ {
			var channel gltf.AnimationChannel = channels[c]
			var channelNode i32 = channel.node
			var nodeChannelOffset i32 = sources[channelNode].offset
			var nodeChannelCount i32 = sources[channelNode].count
			for k := 0; k < nodeChannelCount; k++ {
				var nodeChannelIndex i32 = indices[nodeChannelOffset + k]
				if nodeChannelIndex == -1 {
					indices[nodeChannelOffset + k] = c
					k = nodeChannelCount // TODO : break
				}
			}
		}

		animation.sources = sources
		animation.indices = indices
		animations = append(animations, len(g_animations))
		g_animations = append(g_animations, animation)
	}

	var nodeCount i32 = gltf.AssetGetNodeCount(asset)
	nodesMap = resize(nodesMap, nodeCount)
	for i := 0; i < nodeCount; i++ {
		nodesMap[i] = -1
	}

	for len(stack) > 0 {
		var stackLen i32 = len(stack)

		stackLen--
		var node i32 = stack[stackLen]
		stack = resize(stack, stackLen)

		if node < 0 {
			matrixStack = mat.MatrixStackPop(matrixStack, 0-node)
		} else {
			var stackPushed i32
			var nodeIndex i32 = len(nodes)
			nodes = append(nodes, node)
			nodesMap[node] = nodeIndex
			var skeletonRoot i32 = g_models[modelIndex].skeleton.root
			if skeletonRoot == -1 {
				var skin gltf.Skin = gltf.NodeGetSkin(asset, node)
				if skin.inverseBindMatrices != -1 {
					var accessor gltf.Accessor = gltf.AssetGetAccessor(asset, skin.inverseBindMatrices)
					g_models[modelIndex].inverseBind = accessor.dataF32
					g_models[modelIndex].jointMatrices = resize(g_models[modelIndex].jointMatrices, len(accessor.dataF32))
				}
				g_models[modelIndex].skeleton.root = skin.skeleton
				g_models[modelIndex].skinned = skin.skeleton >= 0 // TODO : multiple skeleton per scene
				g_models[modelIndex].joints = skin.joints
			}

			var nodeMatrix []f32 = gltf.NodeGetMatrix(asset, node)
			var determinant f32 = mat.MatrixDeterminant(nodeMatrix)
			determinants = append(determinants, determinant)
			var cullFace i32 = gl.BACK
			if determinant < 0.0 {
				cullFace = gl.FRONT
			}
			if len(nodeMatrix) > 0 {
				matrixStack = mat.MatrixStackPush(matrixStack, nodeMatrix)
				stackPushed++
			}

			var last []f32 = mat.MatrixStackLast(matrixStack)
			for mi := 0; mi < 16; mi++ {
				transforms = append(transforms, last[mi])
			}

			var mesh i32 = gltf.NodeGetMesh(asset, node)
			var gltfPrimitives []gltf.Primitive = gltf.MeshGetPrimitives(asset, mesh)
			var gltfPrimitiveCount i32 = len(gltfPrimitives)

			for p := 0; p < gltfPrimitiveCount; p++ {

				var render MeshId = InvalidMesh()

				var gltfPrimitive gltf.Primitive = gltfPrimitives[p]
				var gltfMaterial gltf.Material = gltf.AssetGetMaterial(asset, gltfPrimitive.material)
				var metallicRoughness gltf.MetallicRoughness = gltfMaterial.pbrMetallicRoughness

				var indicesIndex i32 = gltfPrimitive.indices
				var meshCacheCount i32 = len(meshCacheKey)
				var pp i32
				for pp = 0; pp < meshCacheCount; pp++ {
					if meshCacheKey[pp] == indicesIndex {
						render = meshCacheVal[pp]
						pp = meshCacheCount
					}
				}

				if IsValidMesh(render) == false {
					render = meshInstance(asset, gltfPrimitive)
					MeshSetCulling(render, gl.CCW, cullFace)
					meshCacheKey = append(meshCacheKey, indicesIndex)
					meshCacheVal = append(meshCacheVal, render)
				}

				if IsValidMesh(render) == false {
					success = false
					return
				}

				meshes = append(meshes, render)
				var meshMin mat.v3 = g_meshes[render.mesh].min
				meshMin = mat.v3_transform_point(meshMin, last)

				var meshMax mat.v3 = g_meshes[render.mesh].max
				meshMax = mat.v3_transform_point(meshMax, last)

				max = mat.v3_max(meshMax, max)
				min = mat.v3_min(meshMin, min)

				var primitive Primitive

				primitive.mesh = render
				primitive.node = node
				primitive.nodeIndex = nodeIndex
				primitive.baseTexture = loadTexture(asset, dataDir, metallicRoughness.baseColorTexture.index)
				primitive.metalRoughTexture = loadTexture(asset, dataDir, metallicRoughness.metallicRoughnessTexture.index)
				primitive.emissiveTexture = loadTexture(asset, dataDir, gltfMaterial.emissiveTexture.index)
				primitive.normalTexture = loadTexture(asset, dataDir, gltfMaterial.normalTexture.index)
				primitive.occlusionTexture = loadTexture(asset, dataDir, gltfMaterial.occlusionTexture.index)
				primitive.gltfMaterial = gltfMaterial
				primitive.gltfPrimitive = gltfPrimitive
				if MeshUseWeight(render) &&  MeshUseJoint(render) {
					primitive.useSkin = 1
				}

				var effect EffectId = effectInstance(&primitive)
				if EffectIsValid(effect) == false {
					printf("effectInstance failed\n")
					success = false
					return
				}
				primitive.effect = effect

				var primitiveIndex i32 = len(primitives)
				primitives = append(primitives, primitive)

				var alphaMode i32 = gltfMaterial.alphaMode
				if alphaMode == gltf.ALPHA_BLEND {
					transparentMeshes = append(transparentMeshes, primitiveIndex)
				} else if alphaMode == gltf.ALPHA_OPAQUE {
					opaqueMeshes = append(opaqueMeshes, primitiveIndex)
				}

		   }

			var children []i32 = gltf.NodeGetChildren(asset, node)
			var childCount i32 = len(children)
			if stackPushed > 0 {
				stack = append(stack, 0-stackPushed)
			}
			if childCount > 0 {
				for i := 0; i < childCount; i++ {
					stack = append(stack, children[i])
				}
			}
		}
	}

	stack = resize(stack, 0)
	g_models[modelIndex].stack = stack
	g_models[modelIndex].nodes = nodes
	g_models[modelIndex].nodesMap = nodesMap
	g_models[modelIndex].determinants = determinants
	g_models[modelIndex].meshes = meshes
	g_models[modelIndex].primitives = primitives
	g_models[modelIndex].opaqueMeshes = opaqueMeshes
	g_models[modelIndex].transparentMeshes = transparentMeshes
	g_models[modelIndex].meshCacheKey = meshCacheKey
	g_models[modelIndex].meshCacheVal = meshCacheVal
	g_models[modelIndex].animations = animations
	g_models[modelIndex].matrixStack = resize(matrixStack, 0)
	g_models[modelIndex].transforms = transforms
	g_models[modelIndex].max = max
	g_models[modelIndex].min = min

	success = true
}


func AnimationSetTime(id AnimationId, time f32) {
}

func AnimationMorph(left AnimationId, right AnimationId) {
}

func ModelSetAnimation(id ModelId, animation AnimationId) {
}


func animationsUpdate(id ModelId, animId ModelId, animationIndex i32, deltaTime f32, loop bool) (out bool) {
	panicIfNot(ModelIsValid(id), "invalid model")
	var modelIndex i32 = id.model

	var animationCount i32 = len(g_animations)
	if animationIndex >= 0 && animationIndex < animationCount {
		var animated bool = g_models[modelIndex].animated
		var skinned bool = g_models[modelIndex].skinned
		if animated || skinned {
			var animation Animation = g_animations[animationIndex]
			var animMin f32 = animation.min
			var animMax f32 = animation.max
			//var animation Animation = g_animations[g_models[modelIndex].animations[animationIndex]] // ISSUE : index must be precomputed
			var channels []gltf.AnimationChannel = animation.channels
			var samplers []gltf.AnimationSampler = animation.samplers
			var sources []AnimationSource = animation.sources
			var sourceCount i32 = len(sources)
			var indices []i32 = animation.indices

			var transforms []f32 = g_models[modelIndex].transforms
			transforms = resize(transforms, 0)

			var nodeIndex i32
			var tmp2 []f32 = g_models[modelIndex].tmp2
			var identity []f32 = g_models[modelIndex].identity
			var matrixStack []f32 = g_models[modelIndex].matrixStack
			matrixStack = resize(matrixStack, 0)
			matrixStack = mat.MatrixStackPush(matrixStack, identity)

			var stack []i32 = g_models[modelIndex].stack

			var modelAsset gltf.AssetId = g_models[modelIndex].asset
			var animAsset gltf.AssetId = modelAsset
			if ModelIsValid(animId) {
				animAsset = g_models[animId.model].asset
			}
			var roots []i32 = gltf.AssetGetRootNodes(modelAsset)
			var rootCount i32 = len(roots)
			stack = resize(stack, rootCount)
			for i := 0; i < rootCount; i++ {
				stack[i] = roots[i]
			}

			var stackCount i32
			for len(stack) > 0 {
				var stackLen i32 = len(stack)

				stackLen--
				var node i32 = stack[stackLen]

				stack = resize(stack, stackLen)
				if node < 0 {
					stackCount = stackCount - 1
					matrixStack = mat.MatrixStackPop(matrixStack, 0-node)
				} else {
					stackCount = stackCount + 1
					var stackPushed i32 = 0
					tmp2 = mat.MatrixIdentity(tmp2)

					var anim bool
					var nodeMatrix []f32 = gltf.NodeGetMatrix(modelAsset, node)
					if node < sourceCount && node != 24{
						var source AnimationSource = sources[node]
						var nodeChannelCount i32 = source.count
						if nodeChannelCount > 0 {

							var useTX i32
							var useRX i32
							var useSX i32
							var animTranslation v3 = mat.v3_(0.0, 0.0, 0.0)
							var animRotation v4 = mat.v4_(0.0, 0.0, 0.0, 1.0)
							var animScale v3 = mat.v3_(1.0, 1.0, 1.0)
							var nodeChannelOffset i32 = source.offset

							//debugNode(stackCount, asset, node)
							source.time = source.time + source.direction * deltaTime
							if source.time < animMin {
								if loop == true {
									source.time = animMax
								} else {
									source.time = animMin
									source.direction = 1.0
								}
							}
							if source.time > animMax {
								if loop == true {
									source.time = 0.0//animMin
								} else {
									source.time = animMax
									source.direction = -1.0
								}
							}

							for a := 0; a < nodeChannelCount; a++ {
								var nodeChannelIndex i32 = indices[nodeChannelOffset + a]
								var channel gltf.AnimationChannel = channels[nodeChannelIndex] // ISSUE : no index out of range if channels is not initialized

								var index i32 = -1
								var inputAccessor gltf.Accessor = gltf.AssetGetAccessor(animAsset, samplers[channel.sampler].inputA)
								var inputs []f32 = inputAccessor.dataF32
								var inputCount i32 = len(inputs)
								for t := 0; t < inputCount; t++ { // TODO : track time
									if source.time <= inputs[t] {
										index = t
										t = inputCount // ISSUE : break
									}
								}

								if index >= inputCount {
									index = inputCount - 1
								}
								if index < 0 {
									index = 0
								}

								var prev i32 = index - 1
								if prev < 0 {
									prev = 0
								}

								var delta f32 = source.time - inputs[prev]
								var step f32 = inputs[index] - inputs[prev]
								var st f32 = 1.0;
								if step > 0.0 {
									st = delta / step
								}
								var t f32 = st
								if t < 0.0 {
									t = 0.0
								} else if t > 1.0 {
									t = 1.0
								}

								var outputAccessor gltf.Accessor = gltf.AssetGetAccessor(animAsset, samplers[channel.sampler].outputA)
								var outputs []f32 = outputAccessor.dataF32
								var path i32 = channel.path
								if path == gltf.ANIMATION_PATH_TRANSLATION {
									panicIf(outputAccessor.attributeTypeEnum != gltf.TYPE_VEC3, "invalid attribute type")
									panicIf(outputAccessor.componentType != gl.FLOAT, "unhandled component type")
									var x0 f32 = outputs[prev * 3 + 0]
									var y0 f32 = outputs[prev * 3 + 1]
									var z0 f32 = outputs[prev * 3 + 2]

									var x1 f32 = outputs[index * 3 + 0]
									var y1 f32 = outputs[index * 3 + 1]
									var z1 f32 = outputs[index * 3 + 2]

									var x f32 = x0 + (x1 - x0) * t
									var y f32 = y0 + (y1 - y0) * t
									var z f32 = z0 + (z1 - z0) * t

									anim = true
									animTranslation = mat.v3_(x, y, z)
									useTX = 1
								} else if path == gltf.ANIMATION_PATH_ROTATION {
									panicIf(outputAccessor.attributeTypeEnum != gltf.TYPE_VEC4, "invalid attribute type")
									panicIf(outputAccessor.componentType != gl.FLOAT, "unhandled component type")
									var x0 f32 = outputs[prev * 4 + 0]
									var y0 f32 = outputs[prev * 4 + 1]
									var z0 f32 = outputs[prev * 4 + 2]
									var w0 f32 = outputs[prev * 4 + 3]

									var x1 f32 = outputs[index * 4 + 0]
									var y1 f32 = outputs[index * 4 + 1]
									var z1 f32 = outputs[index * 4 + 2]
									var w1 f32 = outputs[index * 4 + 3]

									var x f32 = x0 + (x1 - x0) * t
									var y f32 = y0 + (y1 - y0) * t
									var z f32 = z0 + (z1 - z0) * t
									var w f32 = w0 + (w1 - w0) * t

									//var q mat.v4 = mat.QuaternionSlerp(
									//		mat.v4_normalize(mat.v4_(x0, y0, z0, w0)),
									//		mat.v4_normalize(mat.v4_(x1, y1, z1, w1)), t)
									var q mat.v4 = mat.v4_normalize(mat.v4_(x, y, z, w))

									animRotation = q
									anim = true
									useRX = 1
								} else if path == gltf.ANIMATION_PATH_SCALE {
									panicIf(outputAccessor.attributeTypeEnum != gltf.TYPE_VEC3, "invalid attribute type")
									panicIf(outputAccessor.componentType != gl.FLOAT, "unhandled component type")
									var x0 f32 = outputs[prev * 3 + 0]
									var y0 f32 = outputs[prev * 3 + 1]
									var z0 f32 = outputs[prev * 3 + 2]

									var x1 f32 = outputs[index * 3 + 0]
									var y1 f32 = outputs[index * 3 + 1]
									var z1 f32 = outputs[index * 3 + 2]

									var x f32 = x0 + (x1 - x0) * t
									var y f32 = y0 + (y1 - y0) * t
									var z f32 = z0 + (z1 - z0) * t

									animScale = mat.v3_(x, y, z)
									useSX = 1
									anim = true
								} else if path == gltf.ANIMATION_PATH_WEIGHTS {
								} else {
									panicIf(true, "invalid animation path")
								}
							}

							if anim {
								if useTX == 0 {
									animTranslation = gltf.NodeGetTranslation(modelAsset, node)
								}
								if useRX == 0 {
									animRotation = gltf.NodeGetRotation(modelAsset, node)
								}
								if useSX == 0 {
									animScale = gltf.NodeGetScale(modelAsset, node)
								}
								tmp2 = mat.MatrixCreate2(tmp2, animScale.x, animScale.y, animScale.z,
										animRotation.x, animRotation.y, animRotation.z, animRotation.w,
										animTranslation.x, animTranslation.y, animTranslation.z)
   								matrixStack = mat.MatrixStackPush(matrixStack, tmp2)
								stackPushed++
								out = true
							}

							sources[node] = source
						}
					}
					nodeIndex++

					if anim == false || skinned == false {
						if len(nodeMatrix) > 0 {
							matrixStack = mat.MatrixStackPush(matrixStack, nodeMatrix)
							stackPushed++
						}
					}

					var last []f32 = mat.MatrixStackLast(matrixStack)
					for mi := 0; mi < 16; mi++ {
						transforms = append(transforms, last[mi])
					}

					var children []i32 = gltf.NodeGetChildren(modelAsset, node)
					var childCount i32 = len(children)
					if stackPushed > 0 {
						stack = append(stack, 0-stackPushed)
					}
					if childCount > 0 {
						for i := 0; i < childCount; i++ {
							stack = append(stack, children[i])
						}
					}
				}
			}

			g_models[modelIndex].stack = resize(stack, 0)
			g_models[modelIndex].matrixStack = resize(matrixStack, 0)
			g_models[modelIndex].transforms = transforms
		}
	}
}

func jointsUpdate(id ModelId) {
	panicIfNot(ModelIsValid(id), "invalid model")
	var modelIndex i32 = id.model

	var joints []i32 = g_models[modelIndex].joints
	if len(joints) > 0 {
		var jointMatrices []f32 = g_models[modelIndex].jointMatrices
		var inverseBind []f32 = g_models[modelIndex].inverseBind
		var nodesMap []i32 = g_models[modelIndex].nodesMap
		var transforms []f32 = g_models[modelIndex].transforms
		var tmp []f32 = g_models[modelIndex].tmp
		var tmp2 []f32 = g_models[modelIndex].tmp2
		for j := 0; j < len(joints); j++ {
			var node i32 = joints[j]
			var nodeIndex i32 = nodesMap[node]
			for mi := 0; mi < 16; mi++ {
				tmp2[mi] = transforms[nodeIndex * 16 + mi]
			}

			for mi := 0; mi < 16; mi++ {
				tmp[mi] = inverseBind[j * 16 + mi]
			}

			tmp = mat.MatrixMultiply(tmp, tmp, tmp2)

			for mi := 0; mi < 16; mi++ {
				jointMatrices[j * 16 + mi] = tmp[mi]
			}
		}
	}
}

func debugNode(stackCount i32, asset gltf.AssetId, node i32) {
	for kk := 0; kk < stackCount; kk++ {
		printf("--")
	}

	printf("%s :\n", gltf.NodeGetName(asset, node))
}

func modelUpdate(id ModelId, animId ModelId, animationIndex i32, deltaTime f32, loop bool) {
	panicIfNot(ModelIsValid(id), "invalid model")

	if animationsUpdate(id, animId, animationIndex, deltaTime, loop) {
		jointsUpdate(id)
	}
}

func modelRender(id ModelId, alpha bool) {
	panicIfNot(ModelIsValid(id), "invalid model")

	var tmp []f32 = g_models[id.model].tmp
	var world []f32 = g_models[id.model].world
	var transforms []f32 = g_models[id.model].transforms
	var primitives []Primitive = g_models[id.model].primitives
	var renderables []i32

	var environmentSpecular TextureId = g_models[id.model].environmentSpecular
	var environmentDiffuse TextureId = g_models[id.model].environmentDiffuse
	var brdf TextureId = g_models[id.model].brdf

	var view []f32 = g_models[id.model].view
	var projection []f32 = g_models[id.model].projection
	var jointMatrices []f32 = g_models[id.model].jointMatrices
	var color []f32 = color = g_models[id.model].color
	var cameraPosition []f32 = g_models[id.model].cameraPosition

	if alpha == true {
		renderables = g_models[id.model].transparentMeshes
	} else {
		renderables = g_models[id.model].opaqueMeshes
	}
	var renderableCount i32 = len(renderables)

	for p := 0; p < renderableCount; p++ {
		var renderable i32 = renderables[p]
		var primitive Primitive = primitives[renderable]//renderables[p]]
		var effect EffectId = effectInstance(&primitive)

		EffectTryAssignTexture(effect, SAMPLER_COLOR_0, primitive.baseTexture, g_linearWrap) // TODO : use gltf sampler
		EffectTryAssignTexture(effect, SAMPLER_NORMAL, primitive.normalTexture, g_linearWrap) // TODO : use gltf sampler
		EffectTryAssignTexture(effect, SAMPLER_METAL_ROUGH, primitive.metalRoughTexture, g_linearWrap) // TODO : use gltf sampler
		EffectTryAssignTexture(effect, SAMPLER_ENV_SPECULAR, environmentSpecular, g_linearWrap) // TODO : use gltf sampler
		EffectTryAssignTexture(effect, SAMPLER_ENV_DIFFUSE, environmentDiffuse, g_linearWrap) // TODO : use gltf sampler
		EffectTryAssignTexture(effect, SAMPLER_BRDF, brdf, g_linear0Wrap) // TODO : use gltf sampler
		EffectTryAssignTexture(effect, SAMPLER_EMISSIVE, primitive.emissiveTexture, g_linearWrap) // TODO : use gltf sampler
		EffectTryAssignTexture(effect, SAMPLER_OCCLUSION, primitive.occlusionTexture, g_linearWrap) // TODO : use gltf sampler

		var skinned bool = g_models[id.model].skinned
		if skinned == true {
			for ii := 0; ii < 16; ii++ {
				tmp[ii] = world[ii]
			}
		} else {
			var nodeIndex i32 = primitive.nodeIndex
			var mi i32 // ISSUE : can't use short declaration here
			for mi = 0; mi < 16; mi++ {
				tmp[mi] = transforms[nodeIndex * 16 + mi]
			}
			tmp = mat.MatrixMultiply(tmp, tmp, world)
		}

		EffectAssignMatrix4(effect, UNIFORM_WORLD, tmp, false)
		EffectAssignMatrix4(effect, UNIFORM_VIEW, view, false)
		EffectAssignMatrix4(effect, UNIFORM_PROJECTION, projection, false)

		tmp = mat.MatrixInverse(tmp, tmp)
		EffectAssignMatrix4(effect, UNIFORM_WORLD_INVERSE, tmp, false)
		if primitive.useSkin == 1 {
	  		EffectAssignMatrix4(effect, UNIFORM_SKELETON, jointMatrices, false)
		}

		var metallicRoughness gltf.MetallicRoughness = primitive.gltfMaterial.pbrMetallicRoughness
		if EffectIsValidUniformLocation(effect, UNIFORM_COLOR) {
	  		var baseColorFactor [4]f32
	  		baseColorFactor = metallicRoughness.baseColorFactor
	  		color[0] = baseColorFactor[0]
	  		color[1] = baseColorFactor[1]
	  		color[2] = baseColorFactor[2]
	  		color[3] = baseColorFactor[3]
	  		EffectAssignVector4(effect, UNIFORM_COLOR, color)
		}

		if EffectIsValidUniformLocation(effect, UNIFORM_METAL_ROUGH) {
	  		color[0] = 0.0
	  		color[1] = metallicRoughness.roughnessFactor
	  		color[2] = metallicRoughness.metallicFactor
	  		color[3] = 0.0
	  		EffectAssignVector4(effect, UNIFORM_METAL_ROUGH, color)
		}

		if EffectIsValidUniformLocation(effect, UNIFORM_EMISSIVE) {
	  		var emissiveFactor [4]f32
	  		color[0] = emissiveFactor[0]
	  		color[1] = emissiveFactor[1]
	  		color[2] = emissiveFactor[2]
	  		color[3] = emissiveFactor[3]
	  		EffectAssignVector4(effect, UNIFORM_EMISSIVE, color)
		}

		EffectAssignVector4(effect, UNIFORM_CAMERA_POSITION, cameraPosition)
		EffectAssignVector4(effect, UNIFORM_DEBUG_0, DEBUG_0)

		MeshRender(primitive.mesh)
	}
}
