package mat

// Globals ...
var v2_zero v2 = v2_(0.0, 0.0)
var v2_one  v2 = v2_(1.0, 1.0)

var v4_zero v4 = v4_(0.0, 0.0, 0.0, 0.0)

// v1 ...
func v1_sat(a f32) (out f32) {
	out = f32.max(0.0, f32.min(1.0, a))
}

func v1_lerp_sat(a f32, b f32, t f32) (out f32) {
	t = f32.max(0.0, f32.min(1.0, t))
	out = a * (1.0 - t) + b * t
}

func v1_lerp(a f32, b f32, t f32) (out f32) {
	out = a + (b - a) * t
}

func v1_clamp(a f32, fmin f32, fmax f32) (out f32) {
	out = f32.max(f32.min(a, fmax), fmin)
}

// v2 ...
type v2 struct {
	x f32
	y f32
}

func v2_isnan(v v2) (out bool) {
	out = f32.isnan(v.x) || f32.isnan(v.y)
}

func v2_(x f32, y f32) (out v2) {
	out.x = x
	out.y = y
}

func v2_min(a v2, b v2) (out v2) {
	out = v2_(min(a.x, b.x), min(a.y, b.y))
}

func v2_add(a v2, b v2) (out v2) {
	out.x = a.x + b.x
	out.y = a.y + b.y
}

func v2_sub(a v2, b v2) (out v2) {
	out.x = a.x - b.x
	out.y = a.y - b.y
}

func v2_mul(a v2, b v2) (out v2) {
	out.x = a.x * b.x
	out.y = a.y * b.y
}

func v2_div(a v2, b v2) (out v2) {
	out.x = a.x / b.x
	out.y = a.y / b.y
}

// v3 ...
type v3 struct {
	x f32
	y f32
	z f32
}

func v3_(x f32, y f32, z f32) (out v3) {
	out.x = x
	out.y = y
	out.z = z
}

func v3_x(v v3) (out v3) {
	out.x = v.x
}

func v3_y(v v3) (out v3) {
	out.y = v.y
}

func v3_z(v v3) (out v3) {
	out.z = v.z
}

func v3_eq(a v3, b v3) (out bool) {
	out = a.x == b.x &&
		  a.y == b.y &&
		  a.z == b.z
}

func v3_min(a v3, b v3) (out v3) {
	out.x = min(a.x, b.x)
	out.y = min(a.y, b.y)
	out.z = min(a.z, b.z)
}

func v3_max(a v3, b v3) (out v3) {
	out.x = max(a.x, b.x)
	out.y = max(a.y, b.y)
	out.z = max(a.z, b.z)
}

func v3_min_val() (out v3) {
	out.x = FLOAT_MIN
	out.y = FLOAT_MIN
	out.z = FLOAT_MIN
}

func v3_max_val() (out v3) {
	out.x = FLOAT_MAX
	out.y = FLOAT_MAX
	out.z = FLOAT_MAX
}

func v3_add(a v3, b v3) (out v3) {
	out.x = a.x + b.x
	out.y = a.y + b.y
	out.z = a.z + b.z
}

func v3_neg(a v3) (out v3) {
	out.x = 0.0-a.x
	out.y = 0.0-a.y
	out.z = 0.0-a.z
}

func v3_sub(a v3, b v3) (out v3) {
	out.x = a.x - b.x
	out.y = a.y - b.y
	out.z = a.z - b.z
}

func v3_mul(a v3, b v3) (out v3) {
	out.x = a.x * b.x
	out.y = a.y * b.y
	out.z = a.z * b.z
}

func v3_mulf(a v3, f f32) (out v3) {
	out.x = a.x * f
	out.y = a.y * f
	out.z = a.z * f
}

func v3_dot(a v3, b v3) (out f32) {
	out = a.x * b.x + a.y * b.y + a.z * b.z
}

func v3_length(a v3) (out f32) {
	out = f32.sqrt(a.x * a.x + a.y * a.y + a.z * a.z)
}

func v3_normalize(a v3) (out v3) {
	var l f32 = v3_length(a)
	out.x = a.x / l
	out.y = a.y / l
	out.z = a.z / l
}

func v3_cross(a v3, b v3) (out v3) {
	out.x = a.y*b.z - b.y*a.z
	out.y = b.x*a.z - a.x*b.z
	out.z = a.x*b.y - b.x*a.y
}

func v3_rand() (out v3) {
	out.x = f32.rand()
	out.y = f32.rand()
	out.z = f32.rand()
}

func v3_transform_vector(a v3, m []f32) (out v3) {
	var x f32 = a.x
	var y f32 = a.y
	var z f32 = a.z
	out.x = x * m[0] + y * m[4] + z * m[ 8]
	out.y = x * m[1] + y * m[5] + z * m[ 9]
	out.z = x * m[2] + y * m[6] + z * m[10]
}

func v3_transform_point(a v3, m []f32) (out v3) {
	var x f32 = a.x
	var y f32 = a.y
	var z f32 = a.z
	out.x = x * m[0] + y * m[4] + z * m[ 8] + m[12]
	out.y = x * m[1] + y * m[5] + z * m[ 9] + m[13]
	out.z = x * m[2] + y * m[6] + z * m[10] + m[14]
}

func v3_sat(a v3) (out v3) {
	out.x = f32.max(0.0, f32.min(1.0, a.x))
	out.y = f32.max(0.0, f32.min(1.0, a.y))
	out.z = f32.max(0.0, f32.min(1.0, a.z))
}

func v3_lerp_sat_v1(a v3, b v3, t f32) (out v3) {
	t = f32.max(0.0, f32.min(1.0, t))
	it := 1.0 - t
	out.x = a.x * it + b.x * t
	out.y = a.y * it + b.y * t
	out.z = a.z * it + b.z * t
}


// v4 ...
type v4 struct {
	x f32
	y f32
	z f32
	w f32
}

func v4_(x f32, y f32, z f32, w f32) (out v4) {
	out.x = x
	out.y = y
	out.z = z
	out.w = w
}

func v4_v2v2(xy v2, zw v2) (out v4) {
	out.x = xy.x
	out.y = xy.y
	out.z = zw.x
	out.w = zw.y
}

func v4_xy(in v4) (out v2) {
	out.x = in.x
	out.y = in.y
}

func v4_zw(in v4) (out v2) {
	out.x = in.z
	out.y = in.w
}

func v4_eq(a v4, b v4) (out bool) {
	out = a.x == b.x &&
		  a.y == b.y &&
		  a.z == b.z &&
		  a.w == b.w
}

func v4_sub(a v4, b v4) (out v4) {
	out.x = a.x - b.x
	out.y = a.y - b.y
	out.z = a.z - b.z
	out.w = a.w - b.w
}

func v4_neg(a v4) (out v4) {
	out.x = 0.0-a.x
	out.y = 0.0-a.y
	out.z = 0.0-a.z
	out.w = 0.0-a.w
}

func v4_mul(a v4, b v4) (out v4) {
	out.x = a.x * b.x
	out.y = a.y * b.y
	out.z = a.z * b.z
	out.w = a.w * b.w
}

func v4_mix(a v4, b v4, t f32) (out v4) {
	out.x = a.x + t * (b.x - a.x)
	out.y = a.y + t * (b.y - a.y)
	out.z = a.z + t * (b.z - a.z)
	out.w = a.w + t * (b.w - a.w)
}

func v4_rand()(out v4) {
	out.x = f32.rand()
	out.y = f32.rand()
	out.z = f32.rand()
	out.w = f32.rand()
}

func v4_dot(a v4, b v4) (out f32) {
	out = a.x * b.x + a.y * b.y + a.z * b.z + a.w * b.w
}

func v4_length(a v4) (out f32) {
	out = f32.sqrt(a.x * a.x + a.y * a.y + a.z * a.z + a.w * a.w)
}

func v4_sqlength(a v4) (out f32) {
	out = a.x*a.x + a.y*a.y + a.z*a.z + a.w*a.w
}

func v4_normalize(a v4) (out v4) {
	var l f32 = v4_length(a)
	out.x = a.x / l
	out.y = a.y / l
	out.z = a.z / l
	out.w = a.w / l
}

func v4_transform(a v4, m []f32) (out v4) {
	var x f32 = a.x
	var y f32 = a.y
	var z f32 = a.z
	var w f32 = a.w
	out.x = x * m[0] + y * m[4] + z * m[ 8] + w * m[12]
	out.y = x * m[1] + y * m[5] + z * m[ 9] + w * m[13]
	out.z = x * m[2] + y * m[6] + z * m[10] + w * m[14]
	out.w = x * m[3] + y * m[7] + z * m[11] + w * m[15]
}

func v4_lerp_sat_v1(a v4, b v4, t f32) (out v4) {
	t = f32.max(0.0, f32.min(1.0, t))
	it := 1.0 - t
	out.x = a.x * it + b.x * t
	out.y = a.y * it + b.y * t
	out.z = a.z * it + b.z * t
	out.w = a.w * it + b.w * t
}

